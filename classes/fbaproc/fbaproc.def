## dLabPro class CFBAproc (FBAproc)
## - Definition file
##
## AUTHOR : Matthias Eichner
## PACKAGE: dLabPro/classes
## 
## Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
## - Chair of System Theory and Speech Technology, TU Dresden
## - Chair of Communications Engineering, BTU Cottbus
## 
## This file is part of dLabPro.
## 
## dLabPro is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
## 
## dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
## 
## You should have received a copy of the GNU Lesser General Public License
## along with dLabPro. If not, see <http://www.gnu.org/licenses/>.

PLATFORM: GNUC++
COMPILER: gcc
AR:       ar

PROJECT:  FBAproc
COMMENT:  Base class for frame based analysis classes.
AUTHOR:   Matthias Eichner
VERSION:  1.0

CLASS:    FBAproc
/cxx_nconv                                                                      # Use strict C++ naming conventions

/html MAN: 
       <p>This is the base class for all frame based analysis classes. Currently
       the following derived classes exist:</p>
       <p><table>
         <tr>
           <th>Class</th>
           <th>Description</th>
         </tr>
         <tr>
           <td>MELproc</td>
           <td>Mel scaled spectral analysis</td>
         </tr>
         <tr>
           <td>CPproc</td>
           <td>Cepstrum analysis/synthesis</td>
         </tr>
         <tr>
           <td>LCQproc</td>
           <td>Line cepstrum quefrencies</td>
         </tr>
         <tr>
           <td>LPCproc</td>
           <td>Linear prediction analysis/synthesis</td>
         </tr>
         <tr>
           <td>LSFproc</td>
           <td>Line spectrum frequencies</td>
         </tr>
       </table></p>

       <p>The output data instance contains the following components:
       (N is the number of coefficients generated by the analysis)

       0 ... N-1            :  result of analysis
    N                    :  energy of spectrum
    N+1 ... N+N/2        :  delta of every second coefficient 
    N+N/2+1              :  delta of energy
    N+N/2+2 ... 2*N+1    :  delta-delat of every second coefficient 
    2*N+2                :  delta-delta of energy</p>
END_MAN

## Files
INCLUDE: "kzl_list.h"
INCLUDE: "dlp_data.h"
INCLUDE: "dlp_matrix.h"
INCLUDE: "dlp_math.h"

FILE:    fba_work.cpp
FILE:    fba_fft.cpp
FILE:    fba_synt.cpp
FILE:    fba_stat.cpp

## Defines
DEFINE:  FBA_NOLOG          0
DEFINE:  FBA_LOG            1
DEFINE:  FBA_LOG10          2
DEFINE:  FBA_LOG2           3
DEFINE:  FBA_GRANY          100

## Errors

ERROR:   FBA_BADNAME
COMMENT: '%s' is not a valid %s type.

ERROR:   FBA_BADINPUT
COMMENT: '%s' does not contain valid input data. Make sure it has one numeric component. It may optionally have one symbolic label component.

ERROR:   FBA_BADARG
COMMENT: '%s' is not a valid argument for '%s'. Use '%s'.

ERROR:   FBA_EXTWIN
COMMENT: '%s' does not contain valid window data. Make sure it has one component and %d (wlen) records.

ERROR:   FBA_BADPITCH
COMMENT: '%s' does not contain valid pitch data. Make sure it has 2 numeric components at component 0 and 1.

ERROR:   FBA_BADINTO
COMMENT: '%s' does not contain valid into information. Make sure it has the right format.

ERROR:   FBA_BADDELTATABLE
COMMENT: The field delta_table does not hold a valid delta component lookup table. The table must have %d numeric components and 2 records!

ERROR:   FBA_BADDELTAWEIGHTS
COMMENT: Invalid delta weighting vector (field delta_weights) replaced by standard vector.
LEVEL:   EL_WARNING

ERROR:   FBA_BADSAMP
COMMENT: Sampling rate of input data %s and %s are different.
LEVEL:   EL_WARNING

ERROR:   FBA_BADFRAMELEN
COMMENT: Frame length %d not supported for analysis method %s.
LEVEL:   EL_WARNING

ERROR:   FBA_BADEXCLEN
COMMENT: Length of excitation signal less then desired synthesis length.
LEVEL:   EL_WARNING

ERROR:   FBA_ANALYSE
COMMENT: Analysis of frame %d failed.
LEVEL:   EL_WARNING

ERROR:   FBA_LABEL
COMMENT: Loosing label(s) while framing due to short label length or high continuous rate or big frame length.
LEVEL:   EL_WARNING

ERROR:   FBA_SYNTHESISE
COMMENT: Synthesis of frame %d failed. %s
LEVEL:   EL_WARNING

ERROR:   FBA_CRATE
COMMENT: Continuous rate (%d) exceeds window len (%d).
LEVEL:   EL_WARNING

ERROR:   FBA_SYNINTOLAB
COMMENT: Label of feature vectors does not match intonation control at label %s (no. %d).
LEVEL:   EL_ERROR

ERROR:   FBA_NOTIMPLEMENTED
COMMENT: Feature %s currently not implemented.
LEVEL:   EL_ERROR

## Fields

FIELD:   srate
COMMENT: Sample rate.
TYPE:    double
INIT:    16000.0
CODE:
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );
END_CODE

FIELD:   crate
COMMENT: Continuation rate.
TYPE:    int
INIT:    160
MAN:
  <crate> is the continuation rate of the windows [samples].
END_MAN

FIELD:   type
COMMENT: Type of analysis used by classes derived from FBAproc.
TYPE:    255
INIT:    "LogFFT"
MAN:     Sets the type of analysis. <type> is solely used by classes derived from FBAproc.
         Possible values are:
            - "LogFFT"
            - "BurgLPC"
            - "LevinsonLPC"
            - "Uels"
            - "MelFilter"
END_MAN

FIELD:   wtype
COMMENT: Window type.
TYPE:    255
INIT:    "Blackman"
/html MAN:
  <p>Selects the wighting window.
  Use one of the following window names (case insensitive):</p>
  <p><table>
    <tr>
      <th>Window name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>Hamming</td>
      <td>Hamming window</td>
    </tr>
    <tr>
      <td>Hanning</td>
      <td>Hanning window</td>
    </tr>
    <tr>
      <td>Rectangle</td>
      <td>rectangular window</td>
    </tr>
    <tr>
      <td>Triangle</td>
      <td>triangular window</td>
    </tr>
    <tr>
      <td>Gauss</td>
      <td>Gaussian window</td>
    </tr>
    <tr>
      <td>Symexp</td>
      <td>symmetric exponential window</td>
    </tr>
    <tr>
      <td>Blackman</td>
      <td>Blackman window</td>
    </tr>
    <tr>
      <td>Custom</td>
      <td>User defined window assigned to field window assigned to field &ltwindow&gt.</td>
    </tr>
  </table></p>
END_MAN
CODE:
     if (m_idWindow   ) IDESTROY(m_idWindow   );
END_CODE

FIELD:   wnorm
COMMENT: Enable/disable normalization of window energy.
TYPE:    short
INIT:    0
MAN:
         If set to a value different from zero the window will be normalized \
         (to gain same energy in windowed frame like before windowing).
END_MAN

FIELD:   matrix_analysis
COMMENT: Enable/disable matrix analysis.
TYPE:    short
INIT:    0
MAN:
         If set to a value different from zero the the analysis will not be frame wise but matrix wise\
     (For instance in HFA analysis)
END_MAN

FIELD:   out_dim
COMMENT: Number of output components.
TYPE:    int

FIELD:   real_frame
COMMENT: Internal field that holds the current analysis frame. 
TYPE:    data
FLAGS:   /hidden /noset

FIELD:   imag_frame
COMMENT: Internal field that holds the current analysis frame. 
TYPE:    data
FLAGS:   /hidden /noset

FIELD:   window
COMMENT: Wighting window data.
TYPE:    data
MAN:
    This data instance contains the wigthing window. Use "-set wtype"
    to select the window type. You also may assign a data instance 
    to this field that contains a custom window. It must have one
    numeric component and <wlen> records.
END_MAN
CODE:
    if(m_idWindow->GetNRecs()!=m_nWlen||m_idWindow->GetNComps()!=1)
      return IERROR(this,FBA_EXTWIN,m_idWindow->m_lpInstanceName,m_nWlen,0);
    else dlp_strcpy(m_lpsWtype,"Custom");

    m_idWindow->Tconvert(m_idWindow,T_DOUBLE);
    return MakeWindow(m_nWlen); 
END_CODE

FIELD:   exc
COMMENT: Excitation signal used for synthesis.
TYPE:    data
/html MAN:
    <p>This data instance contains the excitation signal for driving the
    synthesis filter. It is used if {@link exc_type} is set to custom
    (<code>C</code>)
    @see exc_type
END_MAN

FIELD:   labels
COMMENT: Label sequence.
TYPE:    data

FIELD:   energy
COMMENT: Energy per frame.
TYPE:    data

FIELD:   wlen
COMMENT: Window length [samples].
TYPE:    int
INIT:    400
MAN:
  <wlen> is the length of the analysis window (measured in
  [samples]).

  NOTE: The window length must be less than the analysis length.
          Select the analysis length by setting field <len>.
END_MAN
CODE:
  if (m_idWindow   ) IDESTROY(m_idWindow   );
END_CODE

FIELD:   len
COMMENT: Analysis length [samples].
TYPE:    int
INIT:    512
CODE:
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );
END_CODE
MAN:
  <len> is the analysis length (measured in [samples]).

  NOTE: The analysis length must be greater or equal the window length.

END_MAN

FIELD:   preem
COMMENT: Preemphasis coefficient.
TYPE:    double
INIT:    0.0
MAN:
  <preem> is the preemphasis coefficient used for preemphasis
  calculation by

    xï¿½[t] = x[t] - <cpre> x[t-1]

    Note: The value used in HTK is 0.97. 
          The default value in Melfilter is 0.95.

END_MAN

FIELD:   delta_table
COMMENT: Table for controlling delta and delta-delta computation.
TYPE:    data
/html MAN:
  <p>Data instance that defines for which components delta and delta-delta 
  features will be computates by {@link -delta}. The table must comprise excatly
  two records and {@link out_dim} numeric components. The first record specifies
  the components for delta computation, the second record specifies components 
  for delta-delta computation. If {@link delta_table}<code>[0,<i>i</i>]</code> 
  is non-zero, component <i>i</i> of the primary feature vectors is selected for
  delta computation. If {@link delta_table}<code>[1,<i>i</i>]</code> 
  is non-zero, component <i>i</i> of the primary feature vectors is selected for
  delta-delta computation, respectively.</p>

  @see -delta
  @see delta_weights
END_MAN

FIELD:   delta_weights
COMMENT: Delta and delta-delta weighting vector.
TYPE:    data
/html MAN:
  <p>Dynamic feature computation vector (<i>w</i>(-<i>L</i>), ..., <i>w</i>(0),
  ..., <i>w</i>(<i>L</i>))<sup>T</sup> used by method {@link -delta} (see there
  for details on delta-computation). The data instance must comprise exactly one
  record and an odd number of numeric components.</p>
  @see -delta     
  @see delta_table     
END_MAN

FIELD:   sync
COMMENT: Pitch synchron/asynchron analysis/synthesis.
TYPE:    short
INIT:    FALSE
FLAGS:   /noset
MAN:
         Tells wether period synchronuous (sync!=0) or period asynchronuous processing (sync=0) \
         is performed (depending on parameter idPitch of -analyze/-synthesize).
END_MAN

FIELD:   n_periods
COMMENT: Maximum number of periods per frame used in synchronuous analysis mode.
TYPE:    short
INIT:    2

FIELD:   pfa_lambda
COMMENT: Warping constant for bilinear transform at analysis.
TYPE:    double
INIT:    0.0
CODE:
  OnPfaLambdaChangedImpl();
END_CODE
MAN:
         This field my be used by derived classes of FBAproc to perform spectral warping at analysis.
END_MAN

FIELD:   syn_lambda
COMMENT: Warping constant for bilinear transform at synthesis.
TYPE:    double
INIT:    0.0
MAN:
         This field my be used by derived classes of FBAproc to perform spectral warping at synthesis.
END_MAN

FIELD:   warp
COMMENT: Warping matrix for bilinear transform (used for VTN).
TYPE:    data
MAN:
         This field my be used by derived classes of FBAproc to perform spectral warping.
END_MAN

FIELD:   DC
COMMENT: DC of input signal.
TYPE:    double
FLAGS:   /noset

FIELD:   min_log
COMMENT: Floor value for logarithm.
TYPE:    double
INIT:    -10.39720770839917918
FLAGS:   /hidden /noset

FIELD:   quantization
COMMENT: Resolution of input signal [Bit].
TYPE:    short
INIT:    16
CODE:
         m_nMinLog=log(dlm_pow(2,-m_nQuantization+1));
END_CODE

FIELD:   base_f0
COMMENT: Mean base frequency (Hz) used for synthesis.
TYPE:    float
INIT:    100.0

FIELD:   base_i0
COMMENT: Mean intensity (dB) used for synthesis.
TYPE:    float
INIT:    0.0

FIELD:   exc_type
COMMENT: Type of excitation generation.
TYPE:    2
INIT:    "R"
/html MAN:
  <p>Type of excitation generation.<p>
  <table><tr><td>type</td><td>voiced</td><td>unvoiced</td></tr>
         <tr><td>P</td><td>pulse train</td><td>white noise</td></tr>
         <tr><td>G</td><td>glottal shape</td><td>white noise</td></tr>
         <tr><td>R</td><td>linear randomized phase</td><td>white noise</td></tr>
  </table>
END_MAN

FIELD:   nse_len
COMMENT: Number frames in noise buffer
TYPE:    int
INIT:    300
CODE:
  return dlm_noisesetup(m_nNseLen,m_nNsePrc,
      m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
      m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);
END_CODE
/html MAN:
  <p>This defines the size of the noise buffer.
  The noise estimation for the current frame uses
  at most this number of frames bevor the current one.
  Which of that last <code>nse_len</code> frames are
  actually used for estimation is defined by {@link nse_prc}.
  The floor used for noise reduction is set by {@link nse_flr}.</p>
  <p><span class="warning">Warning:</span> Noise reduction
  musst be enabled in the derived analysis class.
  Actually the following classes support it:</p>
  <ul>
    <li><code>MELproc</code> (insert "N" in mf_type)
    <li><code>FFTproc</code> (use option /nse)
  </ul>
END_MAN

FIELD:   nse_prc
COMMENT: Percentage for frames in noise buffer used for noise estimation
TYPE:    double
INIT:    0.3
CODE:
  return dlm_noisesetup(m_nNseLen,m_nNsePrc,
      m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
      m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);
END_CODE
/html MAN:
  <p>This defines which frames of the noise buffer are
  used for noise estimation. The size of the buffer
  is set by {@link nse_len}. For all frames in the buffer
  the energy is calculated. The estimated noise is the
  average of the <code>nse_prc</code> percentage of the
  frames in the buffer with the lowest energy.</p>
  <p><span class="warning">Warning:</span> Noise reduction
  musst be enabled in the derived analysis class.
  For supported classes see {@link nse_len}.</p>
END_MAN

FIELD:   nse_flr
COMMENT: Noise floor used for noise reduction
TYPE:    data
CODE:
  if(CData_GetNComps(m_idNseFlr)!=1 || CData_GetCompType(m_idNseFlr,0)!=T_FLOAT){
    m_idNseFlr=NULL;
    IERROR(this,ERR_GENERIC,"Noise floor data object does not contain only one component of type float.",0,0);
  }
  return dlm_noisesetup(m_nNseLen,m_nNsePrc,
      m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
      m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);
END_CODE
/html MAN:
  <p>This defines the floor used for noise reduction.
  The data object should contain one component with type
  floor. The number of records should match the dimension
  of the noise reduction.</p>
  <p><span class="warning">Warning:</span> Noise reduction
  musst be enabled in the derived analysis class.
  For supported classes see {@link nse_len}.</p>
END_MAN

FIELD:   nse_use
COMMENT: Should the frames be use for noise estimation
TYPE:    bool
INIT:    TRUE
CODE:
  return dlm_noisefrc(m_bNseUse);
END_CODE
/html MAN:
  <p>With this option you may switch the noise estimation
  off and do only a noise reduction with the last estimated
  noise.</p>
  <p><span class="warning">Warning:</span> Noise reduction
  musst be enabled in the derived analysis class.
  For supported classes see {@link nse_len}.</p>
END_MAN

## Options

OPTION:  /energy
COMMENT: Compute energy for every frame and save to field <energy>.
MAN:
  The energy is computed from the signal:

  e = sum(quad(s_n)) n=0,...,wlen

    See also: </log_energy>
END_MAN

OPTION:  /log_energy
COMMENT: Compute logarithmic energy for every frame and save to field <energy>.
MAN:       
  The energy is computed as the log of the signal energy. 

  e = log(sum(quad(s_n))) n=0,...,wlen

  The argument for the log function is floored to the value in field <min_log>.

    See also: </energy>
END_MAN

OPTION:  /delta_mf
COMMENT: Alternative delta computation algorithm.
MAN:     
    Use delta computation algorithm taken from original implementation of 
    Melfilter by C.Westendorf:

    first order difference : x'(t) = x(t) - x(t-<delay>)

     second order difference: x''(t) = x'(t+<delay>) - x'(t)
                                    = x (t+<delay>) - x(t) - x'(t)
END_MAN

OPTION:  /rmdc
COMMENT: Remove DC mean from signal.
MAN:       
         Remove DC mean from signal. This is applied for each frame individually.
END_MAN

OPTION:  /time_domain_warping
COMMENT: Do warping in time domain.
MAN:     
         Do warping in time domain. This is a applied for each frame individually using function dlm_filter_mfir.
END_MAN

OPTION:  /ana_smooth_fea
COMMENT: Smoothes features after analysis.
/html MAN:
         <p>Smoothes features after analysis according to voiced/unvoiced information.
         Only voiced periods will be smoothed.</p>

         @see -smooth
END_MAN

OPTION:  /ana_smooth_roots
COMMENT: Smoothes roots of features after analysis.
/html MAN:
         <p>Smoothes roots of features after analysis according to voiced/unvoiced information.
         Only voiced periods will be smoothed.</p>

         @see -smooth
END_MAN

OPTION:  /syn_smooth_fea
COMMENT: Smoothes features during synthesis.
/html MAN:
         <p>Smoothes features during synthesis according to voiced/unvoiced information.
         Only voiced periods will be smoothed.</p>

         @see -smooth
END_MAN

OPTION:  /syn_smooth_roots
COMMENT: Smoothes roots of features during synthesis.
/html MAN:
         <p>Smoothes roots of features during synthesis according to voiced/unvoiced information.
         Only voiced periods will be smoothed.</p>

         @see -smooth
END_MAN

OPTION:  /syn_enhancement
COMMENT: Apply feature dependend signal/feature enhancement methods.

OPTION:  /quantize_8
COMMENT: Quantize to 8 bit instead of 16 bit.
MAN:     
         Generally, function <code>-quantize</code> quantizes features to 16 bit. With this option the features will be quantized to 8 bit.
END_MAN

## Methods

METHOD:  -analyze
COMMENT: Convert signal to sequence of frames.
SYNTAX:  (data idSignal, data idPitch, data idReal, data idImag)
/html MAN:
         <p>Convert signal to sequence of frames, apply weigthing window and calculate 
         energy per frame (optional). </p>

         @param idSignal  data instance containing the signal to analyse
         @param idPitch    data instance containing the pitch information
         @param idReal    output data instance for real part 
         @param idImag    output data instance for imaginary part 
         @return O_K      if successfull, NOT_EXEC otherwise
         @see sync
         @see len
         @see crate         
         @see wlen
         @see wtype
         @see wnorm
END_MAN

METHOD:  -synthesize
COMMENT: Synthesis. Convert sequence of frames to signal.
SYNTAX:  (data idFea, data idControl, data idSyn)
MAN:
         Synthesis. Convert sequence of frames to signal and copy labels if they exists in <code>idFea</code>.
END_MAN

METHOD:  -delta
COMMENT: Calculate delta and acceleration coefficients.
SYNTAX:  (data in, data out)
/html MAN:
  <p>Computes dynamic features (velocity or "delta" and acceleration or "delta-delta" features) of <code>in</code>,
  appends these features as new components to <code>in</code> and stores the result in <code>out</code>. The computation
  uses a delta weighting vector {@link delta_weights} = (<i>w</i>(-<i>L</i>), ..., <i>w</i>(0), ...,
  <i>w</i>(<i>L</i>))<sup>T</sup> and computes the following values:</p>
  <table class="indent" cellpadding="0" cellspacing="0" border="0" alt="x^\prime(k)=\sum\limits_{k=-L}^L w(i)x(k+i)">
    <tr>
      <td class="hidden" colspan="2"> </td>
      <td class="hidden" style="text-align:center; font-size:6pt"><i>L</i></td>
      <td class="hidden"> </td>
    </tr>
    <tr>
      <td class="hidden" style="vertical-align:middle"><i>x</i>'(<i>k</i>)</td>
      <td class="hidden" style="vertical-align:middle">=</td>
      <td class="hidden" style="text-align:center; font-size:12pt">&sum;</td>
      <td class="hidden" style="vertical-align:middle"><i>w</i>(<i>i</i>)<i>x</i>(<i>k</i>+<i>i</i>)</td>
    </tr>
    <tr>
      <td class="hidden" colspan="2"> </td>
      <td class="hidden" style="text-align:center; font-size:6pt"><i>i</i>=-<i>L</i></td>
      <td class="hidden"> </td>
    </tr>
  </table>
  <p>and</p>
  <table class="indent" cellpadding="0" cellspacing="0" border="0" alt="x^{\prime\prime}(k)=\sum\limits_{k=-L}^L w(i)x^\prime(k+i)">
    <tr>
      <td class="hidden" colspan="2"> </td>
      <td class="hidden" style="text-align:center; font-size:6pt"><i>L</i></td>
      <td class="hidden"> </td>
    </tr>
    <tr>
      <td class="hidden" style="vertical-align:middle"><i>x</i>''(<i>k</i>)</td>
      <td class="hidden" style="vertical-align:middle">=</td>
      <td class="hidden" style="text-align:center; font-size:12pt">&sum;</td>
      <td class="hidden" style="vertical-align:middle"><i>w</i>(<i>i</i>)<i>x</i>'(<i>k</i>+<i>i</i>)</td>
    </tr>
    <tr>
      <td class="hidden" colspan="2"> </td>
      <td class="hidden" style="text-align:center; font-size:6pt"><i>i</i>=-<i>L</i></td>
      <td class="hidden"> </td>
    </tr>
  </table>
  <p>where <i>L</i>=({@link delta_weights}.dim-1)/2.</p>

  <p>The components of <code>in</code> for which delta coeffcients shall be calculated may be selected by the field
  {@link delta_table}. If this field is not set delta and delta-delta coefficients are calculated for all components. 
  If a data instance is assigned to field {@link delta_table}, this instance is interpreted as lookup table for delta
  calculations. The table must have exactly as many numeric components as <code>in</code> and 2 records. The first
  record is used for delta coefficients, the second record is used for the delta-deltas.</p>

  <h3>Example:</h3>
    
  <p>If <i><b>x</b></i> is the feature vector sequence comprising 5 components and {@link delta_table} looks like that:</p>
  <table class="indent">
    <tr><th>  </th><th>r0</th><th>r1</th></tr>
    <tr><th>c0</th><td> 1</td><td> 0</td></tr>
    <tr><th>c1</th><td> 0</td><td> 1</td></tr>
    <tr><th>c2</th><td> 0</td><td> 0</td></tr>
    <tr><th>c3</th><td> 1</td><td> 1</td></tr>
    <tr><th>c4</th><td> 1</td><td> 0</td></tr>
  </table>
  <p>then the deltas are calculated for components 0, 3 and 4, and the delta-deltas are generated for components 1 and
  3. The resulting feature vector has the following 10 components:</p>
  <p class="indent">(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>,
  <i>x</i><sub>4</sub>, <i>x</i>'<sub>0</sub>, <i>x</i>'<sub>3</sub>, <i>x</i>'<sub>4</sub>, 
  <i>x</i>''<sub>1</sub>, <i>x</i>''<sub>3</sub>)<sup>T</sup>.

    @param in  Feature vector sequence
    @param out Resulting vector sequence with dynamic features.
    @see delta_table
    @see delta_weights
END_MAN
CODE:
  if (m_bDeltaMf)
    DeltaMF(in,out);
  else
    DeltaFBA(in,out);
END_CODE

METHOD:  -fixed2floating
COMMENT: Dequantization of numeric components from fixed point (short) to floating point.
SYNTAX:  (data in, data out)
MAN:
  Quantization of numeric components from fixed point (short) to floating point.
  This method is deprecated. Used method -dequantize of class data.
END_MAN
CODE:
  IERROR(this,ERR_GENERIC,"This method is deprecated. Use Used method -dequantize of class data instead.",0,0);
  CData_Quantize(in,out);
END_CODE

METHOD:  -floating2fixed
COMMENT: Quantization of numeric components from floating point to fixed point (short).
SYNTAX:  (data in, data out)
MAN:
  Quantization of numeric components from floating point to fixed point (short).
  This method is deprecated. Used method -quantize of class data.
END_MAN
CODE:
  IERROR(this,ERR_GENERIC,"This method is deprecated. Use Used method -quantize of class data instead.",0,0);
  CData_Dequantize(in,out);
END_CODE

METHOD:  -get_durations_from_inventory
COMMENT: Replaces zero entries of phoneme durations of into data instance with inventory durations.
SYNTAX:  (data idFea, data idInto)
/html MAN:
         <p>As the into file format specification says that zero entries of phonem durations
         is supposed to replaced by the inherited durations of the inventory, this function does it.</p>
         <p><code>idFea</code> is excpected to contain the concatenated inventory units.</p>

         @param idFea contains the concatenated feature vector sequence taken from an inventory
         @param idInto intonation control data instance where the zero durations will be replaced.
END_MAN

METHOD:  -gen_pitch
COMMENT: Generates the pitch from prosodic information.
SYNTAX:  (data idProso, data idPitch)
/html MAN:
         <p>Compute the pitch data required for synthesis
         from prosodic information of the utterance. idProso is expected to have 
         the following component structure:</p>
         
         <p><table>
           <tr>
             <th>Idx</th>
             <th>Type</th>
             <th>Description</th>
           </tr>
           <tr>
             <td>0</td>
             <td>numeric</td>
             <td>Length of segment in samples</td>
           </tr>
           <tr>
             <td>1</td>
             <td>numeric</td>
             <td>Fundamential frequency (F0) in Hz</td>
           </tr>
           <tr>
             <td>2</td>
             <td>numeric</td>
             <td>Voiceness (0-unvoiced ... 1-voiced)</td>
           </tr>
         </table></p>

         <p>The resulting instance idPitch has the following component structure:</p>
         <p><table>
           <tr>
             <th>Idx</th>
             <th>Type</th>
             <th>Description</th>
           </tr>
           <tr>
             <td>0</td>
             <td>numeric</td>
             <td>Length of signal period in samples</td>
           </tr>
           <tr>
             <td>1</td>
             <td>numeric</td>
             <td>Voiceness (0-unvoiced ... 1-voiced)</td>
           </tr>
         </table></p>

         <h3>Example</h3>
         <pre>
         -----------------------------------------------------------------------------------------
           m rec. (offset):      pm   v/uv
                0 (000000):     159      0
                1 (000004):     159      0
                2 (000008):     120      1
         -----------------------------------------------------------------------------------------
         </pre>
         <p>where pm (column 0)= sampling_freq./F0</p>

  <h4>Remarks</h4>
  <ul>
    <li><span class="warning">Warning:</span> The implemention may produce unsynchoneous pitch information. FIXME!.</li>
  </ul>

  @param  idProso  Prosodic information (duration, F0, voiceness)
  @param  idPitch  Generated pitch data
  @return O_K if successful, an error code otherwise
END_MAN

METHOD:  -modEx
COMMENT: Generates amplitude modulated excitation data from pitch.
SYNTAX:  (data dPitch, data dExcite)
/html MAN:  
      <p>Generates amplitude modulated excitation data from pitch.</p>

      @param dGain   gain sequence
      @param dPitch  pitch sequence
      @param dExcite resulting modulated pitch train
END_MAN

METHOD: -resample_pitch
COMMENT: Resamples excitation to new mean F0 for voice conversion.
SYNTAX:  (data idPitch, data idNewPitch, int nFFreq)
/html MAN:  
      <p>Resamples excitation for voice conversion. idPitch
      must contain the pitch generated using -genPitch or
      extracted from natural speech. nFFreq is the new 
      fundamential frequency in Hz. Unvoiced parts remain
      unchanged. Result is time synchronous to input.</p>

      @param   idPitch     Source data instance containing original pitch
      @param   idNewPitch  Target data instance containing new pitch
      @param   nFFreq      Target fundamential frequency (mean over voiced parts)

      @see -gen_pitch
END_MAN

METHOD: -compress_pitch
COMMENT: Resamples pitch with compressed pitch contour.
SYNTAX:  (data idPitch, data idNewPitch, float factor)
/html MAN:  
      <p>Resamples pitch with compressed pitch contour. idPitch
      must contain the pitch generated using -genPitch or
      extracted from natural speech. Result is time synchronous to input.</p>
      <p>
      <table>
        <tr>
          <th><code>factor</code></th>
          <th>description</th>
        </tr>
        <tr>
          <td><code>       factor  < 0.0 </code></td>
          <td>reversing pitch contour</td>
        </tr> 
        <tr>
          <td><code>       factor == 0.0 </code></td>
          <td>monotoning pitch contour</td>
        <tr>
        </tr> 
        <tr>
          <td><code> 0.0 < factor  < 1.0 </code></td>
          <td>flatening pitch contour</td>
        </tr> 
          <td><code>       factor == 1.0 </code></td>
          <td>nothing is done.</td>
        <tr>
          <td><code> 1.0 < factor        </code></td>
          <td>expanding pitch contour</td>
        </tr>
      </table>
      </p>

      @param   idPitch     Source data instance containing original pitch
      @param   idNewPitch  Target data instance containing new pitch
      @param   factor      Compression factor

      @see -gen_pitch
END_MAN

METHOD: -adjust_speech_rate
COMMENT: Resamples pitch to new speech rate.
SYNTAX:  (data idPitch, data idNewPitch, data idFea, data idNewFea, float rate)
/html MAN:  
      <p>Resamples pitch to new speech rate. The feature vectors were
      synchronized to the new pitch. Only voiced parts will be adjusted.
      idPitch must contain the pitch generated using -genPitch or
      extracted from natural speech.</p>

      <p>
      <table>
        <tr>
          <th><code>rate</code></th>
          <th>description</th>
        </tr>
        <tr>
          <td><code> 0.0 < rate  < 1.0 </code></td>
          <td>speed up</td>
        </tr> 
          <td><code>       rate == 1.0 </code></td>
          <td>nothing is done.</td>
        <tr>
          <td><code> 1.0 < rate        </code></td>
          <td>slowing</td>
        </tr>
      </table>
      </p>

      @param   idPitch     Source data instance containing original pitch
      @param   idNewPitch  Target data instance containing new pitch
      @param   idFea       Source data instance containing feature vectors
      @param   idNewFea    Target data instance containing new feature vectors
      @param   rate      speech rate

      @see -gen_pitch
END_MAN

METHOD: -align_frames_to_pitch
COMMENT: aligns frames to pitch to match number of pitches
SYNTAX:  (data idPitch, data idFea, data idNewFea)
/html MAN:  
      <p>Aligns frames to pitch. The feature vectors were
      synchronized to the new pitch. If @link m_nSync is <code>TRUE</code>
      nothing is done. If number of frames is always equal to number of pitches
      nothing ist done. idPitch must contain the pitch generated using -genPitch or
      extracted from natural speech.</p>

      @param   idPitch     Source data instance containing original pitch
      @param   idFea       Source data instance containing feature vectors
      @param   idNewFea    Target data instance containing new feature vectors

      @see -gen_pitch
END_MAN

METHOD: -smooth
COMMENT: Smoothes input array along records.
SYNTAX:  (data idIn, data idPm, data idOut)
/html MAN:  
      <p>Smoothes each component of the data in <idIn>
      separately along the record axis. Usable, if <idIn>
      contains signal feature vectors for consecutive frames, where
      the components of <idIn> belong to the elements of
      the feature vectors and the records belongs to the frames.
      If <idPm> is non-NULL smoothing is done according to voiced/
      unvoiced information given in <idPm> at component 1. Only voiced
      records will be smoothed. The result is written to <idOut>.
      Two types of smoothing currently implemented. These are
      <ul>
        <li>"/[ana|syn]_smooth_fea"   <tab id=t_smooth_1>- smoothing via lowpass filtering features.</li>
        <li>"/[ana|syn]_smooth_roots" <tab to=t_smooth_1>- smoothing via lowpass filtering of roots of features.</li>
      </ul></p>
END_MAN

METHOD:  -roots_track
COMMENT: Calculates roots via iterative root tracking.
SYNTAX:  (data idFea, data idReal, data idImag, data idVUV)
MAN:
         Calculates roots of cepstrum via iterative root tracking.
         If tracking failed for particular frames this is a hint to
         unvoiced frames. If idVUV!=NULL this v/uv estimation is stored there.
         The roots of these frames were calculated via dlm_roots.
END_MAN:

METHOD:  -poly
COMMENT: Calculates polynomial from roots.
SYNTAX:  (data idRootReal, data idRootsImag, data idPoly)
/html MAN:
         Calculates the polynomial of the roots given in
         <code>idRootsReal</code> and <code>idRootsImag</code>
         and stores it <code>idPoly</code>. The roots for one polynomial have to
         stored in one record. For every record of roots one polynomial is
         calculated.
END_MAN

METHOD:  -status
COMMENT: Display status information.
SYNTAX:  ()

## Release notes

#NOTE:    Note 01
#COMMENT: On using check - level for analysis
#MAN:
#END_MAN

#NOTE:    Note 02
#COMMENT: On using delta_delay value
#MAN:
#END_MAN


## System functions

HEADERCODE:
  struct SLAB { const char* phoneme; INT32 pos; };
END_CODE

INITCODE:
  INIT;

  // Adjust Output dimension
  m_nOutDim = m_nLen;
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );
  
END_CODE

RESETCODE:

  RESET;

  // Init internal instances
  DeltaCheckWeights(TRUE);
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );

END_CODE

DONECODE:

  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );
  if (m_idLabels   ) IDESTROY(m_idLabels   );
  if (m_idWarp     ) IDESTROY(m_idWarp     );

  DONE;
END_CODE

## Generate files
-cgen
quit

## EOF

/* dLabPro class CVar (var)
 * - Variable
 *
 * AUTHOR : Christian-M. Westendorf, Matthias Wolff
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify var.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
#include <time.h>
/*}}CGEN_END */
#include "dlp_var.h"

/* Class CVar */

void CVar_Constructor(CVar* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CVar_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CVar),
		__FILE__,__LINE__,"var",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CVar_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CVar_Reset;
	_this->m_lpBaseInstance->Init              = CVar_Init;
	_this->m_lpBaseInstance->Serialize         = CVar_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CVar_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CVar_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CVar_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CVar_Copy;
	_this->m_lpBaseInstance->ClassProc         = CVar_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CVar_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CVar_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CVar_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CVar_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"var");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"var");
	dlp_strcpy(BASEINST(_this)->m_version.no,"2.5.1");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOACTIVATE | CS_SECONDARY;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CVar_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CVar);
	{
	/*{{CGEN_DONECODE */
  DONE;
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CVar_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	DEBUGMSG(-1,"CVar_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("*=","",LPMF(CVar,OnMultiplySet),"Multiply variable with value",0,"<value> <var this>","")
	REGISTER_METHOD("++=","",LPMF(CVar,OnIncrementSet),"Increment variable",0,"<var this>","")
	REGISTER_METHOD("+=","",LPMF(CVar,OnAddSet),"Add value to variable",0,"<value> <var this>","")
	REGISTER_METHOD("--=","",LPMF(CVar,OnDecrementSet),"Decrement variable",0,"<var this>","")
	REGISTER_METHOD("-=","",LPMF(CVar,OnSubtractSet),"Subtract value from variable",0,"<value> <var this>","")
	REGISTER_METHOD("-bset","",LPMF(CVar,OnBset),"Set boolean value",0,"<BOOL bVal> <var this>","")
	REGISTER_METHOD("-intv","",LPMF(CVar,OnIntv),"Define interval for randomized selection.",0,"<double nLow> <double nHi> <double nDelta> <var this>","")
	REGISTER_METHOD("-iset","iset",LPMF(CVar,OnIset),"Set instance value",0,"<instance iVal> <var this>","")
	REGISTER_METHOD("-rset","",LPMF(CVar,OnRset),"Assign data instance for randomized selection",0,"<data idRndSet> <int nIc> <var this>","")
	REGISTER_METHOD("-sset","sset",LPMF(CVar,OnSset),"Set string value",0,"<string sVal> <var this>","")
	REGISTER_METHOD("-status","",LPMF(CVar,OnStatus),"Print status of var",0,"<var this>","")
	REGISTER_METHOD("-vset","vset",LPMF(CVar,OnVset),"Set numeric value",0,"<complex nVal> <var this>","")
	REGISTER_METHOD("/=","",LPMF(CVar,OnDivideSet),"Divide variable by value",0,"<value> <var this>","")
	REGISTER_METHOD("=","",LPMF(CVar,OnSet),"Set variable value",0,"<value> <var this>","")

	/* Register fields */
	REGISTER_FIELD("b_val","",LPMV(m_bBVal),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)0)
	REGISTER_FIELD("delta","",LPMV(m_nDelta),NULL,"",FF_HIDDEN | FF_NOSET,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("hi","",LPMV(m_nHi),NULL,"",FF_HIDDEN | FF_NOSET,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("icomp","",LPMV(m_nIcomp),NULL,"",FF_HIDDEN | FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("ind","",LPMV(m_nInd),NULL,"",FF_HIDDEN | FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("low","",LPMV(m_nLow),NULL,"",FF_HIDDEN | FF_NOSET,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("n_val","",LPMV(m_nNVal),NULL,"",FF_HIDDEN | FF_NOSET,3009,1,"complex",CMPLX(0.))
	REGISTER_FIELD("norm","",LPMV(m_nNorm),NULL,"",FF_HIDDEN | FF_NOSET,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("rnd_set","",LPMV(m_idRndSet),NULL,"",FF_HIDDEN | FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("s_val","",LPMV(m_lpsSVal),NULL,"",FF_HIDDEN | FF_NOSET,5000,1,"string",NULL)
	REGISTER_FIELD("set_size","",LPMV(m_nSetSize),NULL,"",FF_HIDDEN | FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("type","",LPMV(m_nType),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)T_COMPLEX)

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,VAR_NOTSUPPORTED,"%s not supported%s.")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CVar_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	DEBUGMSG(-1,"CVar_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CVar_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	DEBUGMSG(-1,"CVar_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  RESET;
  srand(time(NULL));
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CVar_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  CVar_Exec(_this);
  CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CVar_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  SAVE;
  if (_this->m_nType==T_INSTANCE)
  {
    char sBuf[255];
    sprintf(sBuf,    "Cannot serialize instance variables (%s).",BASEINST(_this)->m_lpInstanceName);
    IERROR(_this,ERR_GENERIC,sBuf,0,0);
  }
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CVar_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  SAVE;
  if (_this->m_nType==T_INSTANCE)
  {
    char sBuf[255];
    sprintf(sBuf,    "Cannot serialize instance variables (%s).",BASEINST(_this)->m_lpInstanceName);
    IERROR(_this,ERR_GENERIC,sBuf,0,0);
  }
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CVar_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  if (_this->m_nType==T_INSTANCE)
  {
    char sBuf[255];
    sprintf(sBuf,    "Cannot deserialize instance variables (%s).",BASEINST(_this)->m_lpInstanceName);
    IERROR(_this,ERR_GENERIC,sBuf,0,0);
  }
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CVar_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  if (_this->m_nType==T_INSTANCE)
  {
    char sBuf[255];
    sprintf(sBuf,    "Cannot deserialize instance variables (%s).",BASEINST(_this)->m_lpInstanceName);
    IERROR(_this,ERR_GENERIC,sBuf,0,0);
  }
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CVar_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CVar_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CVar* CVar_CreateInstance(const char* lpName)
{
	CVar* lpNewInstance;
	ICREATEEX(CVar,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CVar_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE | CS_SECONDARY;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CVar::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CVar::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CVar_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CVar_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "var";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Variable";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CVar";
	lpClassWord->ex.fct.lpAuthor    = "Christian-M. Westendorf, Matthias Wolff";

	dlp_strcpy(lpClassWord->lpName             ,"var");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"2.5.1");

	return O_K;
}

INT16 CVar_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CVar_GetClassInfo(lpClassWord);
}

BOOL CVar_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"var",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CVar_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	DEBUGMSG(-1,"CVar_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CVar_OnMultiplySet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_MultiplySet(_this);
	return __nErr;
}

INT16 CVar_OnIncrementSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_IncrementSet(_this);
	return __nErr;
}

INT16 CVar_OnAddSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_AddSet(_this);
	return __nErr;
}

INT16 CVar_OnDecrementSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_DecrementSet(_this);
	return __nErr;
}

INT16 CVar_OnSubtractSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_SubtractSet(_this);
	return __nErr;
}

INT16 CVar_OnBset(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    BOOL bVal = MIC_GET_B(1,0);
    return CVar_Bset(_this,bVal);
/* <-- User defined code */
}

INT16 CVar_OnIntv(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    FLOAT64 nDelta = MIC_GET_N(1,0);
    FLOAT64 nHi = MIC_GET_N(2,1);
    FLOAT64 nLow = MIC_GET_N(3,2);
    return CVar_Intv(_this,nLow, nHi, nDelta);
/* <-- User defined code */
}

INT16 CVar_OnIset(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    CDlpObject* iVal = MIC_GET_I(1,1);
    return CVar_Iset(_this,iVal);
/* <-- User defined code */
}

INT16 CVar_OnRset(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    INT32 nIc = (INT32)MIC_GET_N(1,0);
    data* idRndSet = MIC_GET_I_EX(idRndSet,data,2,1);
    return CVar_Rset(_this,idRndSet, nIc);
/* <-- User defined code */
}

INT16 CVar_OnSset(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    char* sVal = MIC_GET_S(1,0);
    return CVar_Sset(_this,sVal);
/* <-- User defined code */
}

INT16 CVar_OnStatus(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_Status(_this);
	return __nErr;
}

INT16 CVar_OnVset(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
  	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    COMPLEX64 nVal = MIC_GET_C(1,0);
    return CVar_Vset(_this,nVal);
/* <-- User defined code */
}

INT16 CVar_OnDivideSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_DivideSet(_this);
	return __nErr;
}

INT16 CVar_OnSet(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CVar,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CVar_Set(_this);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CVar_MultiplySet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"*=");
	return O_K;
}

INT16 CVar_IncrementSet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"++=");
	return O_K;
}

INT16 CVar_AddSet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"+=");
	return O_K;
}

INT16 CVar_DecrementSet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"--=");
	return O_K;
}

INT16 CVar_SubtractSet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"-=");
	return O_K;
}

INT16 CVar_Bset(CVar* _this, BOOL bVal)
{
    dlp_free(_this->m_lpsSVal);
    _this->m_lpsSVal    = NULL;
    BASEINST(_this)->m_iAliasInst = NULL;
    _this->m_nType      = T_BOOL;
    _this->m_bBVal      = bVal;
	return O_K;
}

INT16 CVar_Intv(CVar* _this, FLOAT64 nLow, FLOAT64 nHi, FLOAT64 nDelta)
{
    dlp_free(_this->m_lpsSVal);
    _this->m_lpsSVal  = NULL;
    _this->m_nLow     = nLow;
    _this->m_nHi      = nHi;
    _this->m_nDelta   = nDelta;
    _this->m_nType    = T_RDOUBLE;
    _this->m_nSetSize = (INT32)((nHi-nLow)/nDelta)+1;
    _this->m_nNorm    = (FLOAT64)RAND_MAX/(FLOAT64)_this->m_nSetSize;
	return O_K;
}

INT16 CVar_Iset(CVar* _this, CDlpObject* iVal)
{
    dlp_free(_this->m_lpsSVal);
    _this->m_lpsSVal    = NULL;
    _this->m_nType      = T_INSTANCE;
    BASEINST(_this)->m_iAliasInst = iVal;
	return O_K;
}

INT16 CVar_Rset(CVar* _this, data* idRndSet, INT32 nIc)
{
    if (!idRndSet) return NOT_EXEC;
    if (nIc>=CData_GetNComps(idRndSet)) return NOT_EXEC;
    dlp_free(_this->m_lpsSVal);
    _this->m_lpsSVal  = NULL;
    _this->m_nIcomp   = nIc;
    _this->m_idRndSet = BASEINST(idRndSet);
    _this->m_nSetSize = CData_GetNRecs(idRndSet);
    _this->m_nNorm    = (FLOAT64)RAND_MAX/(FLOAT64)_this->m_nSetSize;
    _this->m_nType    = T_RDDATA;
    if (CData_GetCompType(idRndSet,nIc)<256) _this->m_nType = T_RSDATA;
	return O_K;
}

INT16 CVar_Sset(CVar* _this, char* sVal)
{
    dlp_free(_this->m_lpsSVal);
    BASEINST(_this)->m_iAliasInst = NULL;
    _this->m_nType      = T_STRING;
    _this->m_lpsSVal    = (char*)dlp_calloc(dlp_strlen(sVal)+1,sizeof(char));
    dlp_strcpy(_this->m_lpsSVal,sVal);
	return O_K;
}

INT16 CVar_Vset(CVar* _this, COMPLEX64 nVal)
{
    dlp_free(_this->m_lpsSVal);
    _this->m_lpsSVal    = NULL;
    BASEINST(_this)->m_iAliasInst = NULL;
    _this->m_nType      = T_COMPLEX;
    _this->m_nNVal      = nVal;
	return O_K;
}

INT16 CVar_DivideSet(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"/=");
	return O_K;
}

INT16 CVar_Set(CVar* _this)
{
    MIC_CHECK;
    CVar_PopOwnValue(_this);
    return CVar_SetOp(_this,"=");
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CVar::CVar(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CVar_Constructor(this,lpInstanceName,bCallVirtual);
}

CVar::~CVar()
{
	CVar_Destructor(this);
}

INT16 CVar::AutoRegisterWords()
{
	return CVar_AutoRegisterWords(this);
}

INT16 CVar::Init(BOOL bCallVirtual)
{
	return CVar_Init(this,bCallVirtual);
}

INT16 CVar::Reset(BOOL bResetMembers)
{
	return CVar_Reset(this,bResetMembers);
}

INT16 CVar::ClassProc()
{
	return CVar_ClassProc(this);
}

INT16 CVar::Serialize(CDN3Stream* lpDest)
{
	return CVar_Serialize(this,lpDest);
}

INT16 CVar::SerializeXml(CXmlStream* lpDest)
{
	return CVar_SerializeXml(this,lpDest);
}

INT16 CVar::Deserialize(CDN3Stream* lpSrc)
{
	return CVar_Deserialize(this,lpSrc);
}

INT16 CVar::DeserializeXml(CXmlStream* lpSrc)
{
	return CVar_DeserializeXml(this,lpSrc);
}

INT16 CVar::Copy(CDlpObject* __iSrc)
{
	return CVar_Copy(this,__iSrc);
}

INT16 CVar::InstallProc(void* lpItp)
{
	return CVar_InstallProc(lpItp);
}

CVar* CVar::CreateInstance(const char* lpName)
{
	return CVar_CreateInstance(lpName);
}

INT16 CVar::GetClassInfo(SWord* lpClassWord)
{
	return CVar_GetClassInfo(lpClassWord);
}

INT16 CVar::GetInstanceInfo(SWord* lpClassWord)
{
	return CVar_GetInstanceInfo(this,lpClassWord);
}

BOOL CVar::IsKindOf(const char* lpClassName)
{
	return CVar_IsKindOf(this,lpClassName);
}

INT16 CVar::ResetAllOptions(BOOL bInit)
{
	return CVar_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CVar::OnMultiplySet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnMultiplySet(this);
}

INT16 CVar::OnIncrementSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnIncrementSet(this);
}

INT16 CVar::OnAddSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnAddSet(this);
}

INT16 CVar::OnDecrementSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnDecrementSet(this);
}

INT16 CVar::OnSubtractSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnSubtractSet(this);
}

INT16 CVar::OnBset()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnBset(this);
}

INT16 CVar::OnIntv()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnIntv(this);
}

INT16 CVar::OnIset()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnIset(this);
}

INT16 CVar::OnRset()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnRset(this);
}

INT16 CVar::OnSset()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnSset(this);
}

INT16 CVar::OnStatus()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnStatus(this);
}

INT16 CVar::OnVset()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnVset(this);
}

INT16 CVar::OnDivideSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnDivideSet(this);
}

INT16 CVar::OnSet()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CVar_OnSet(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CVar::MultiplySet()
{
	return CVar_MultiplySet(this);
}

INT16 CVar::IncrementSet()
{
	return CVar_IncrementSet(this);
}

INT16 CVar::AddSet()
{
	return CVar_AddSet(this);
}

INT16 CVar::DecrementSet()
{
	return CVar_DecrementSet(this);
}

INT16 CVar::SubtractSet()
{
	return CVar_SubtractSet(this);
}

INT16 CVar::Bset(BOOL bVal)
{
	return CVar_Bset(this,bVal);
}

INT16 CVar::Intv(FLOAT64 nLow, FLOAT64 nHi, FLOAT64 nDelta)
{
	return CVar_Intv(this,nLow, nHi, nDelta);
}

INT16 CVar::Iset(CDlpObject* iVal)
{
	return CVar_Iset(this,iVal);
}

INT16 CVar::Rset(data* idRndSet, INT32 nIc)
{
	return CVar_Rset(this,idRndSet, nIc);
}

INT16 CVar::Sset(char* sVal)
{
	return CVar_Sset(this,sVal);
}

INT16 CVar::Vset(COMPLEX64 nVal)
{
	return CVar_Vset(this,nVal);
}

INT16 CVar::DivideSet()
{
	return CVar_DivideSet(this);
}

INT16 CVar::Set()
{
	return CVar_Set(this);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
INT16 CVar::Status()
{
	return CVar_Status(this);
}

INT16 CVar::SetOp(const char* lpsOpname)
{
	return CVar_SetOp(this, lpsOpname);
}

void CVar::PopOwnValue()
{
	CVar_PopOwnValue(this);
}

void CVar::Exec()
{
	CVar_Exec(this);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */

/* dLabPro class CData (data)
 * - Generic data container
 *
 * AUTHOR : g. strecha, dresden
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify data.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_data.h"

/* Class CData */

void CData_Constructor(CData* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CData_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CData),
		__FILE__,__LINE__,"data",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CData_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CData_Reset;
	_this->m_lpBaseInstance->Init              = CData_Init;
	_this->m_lpBaseInstance->Serialize         = CData_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CData_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CData_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CData_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CData_Copy;
	_this->m_lpBaseInstance->ClassProc         = CData_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CData_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CData_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CData_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CData_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"data");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"Data");
	dlp_strcpy(BASEINST(_this)->m_version.no,"2.0.1");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CData_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CData);
	{
	/*{{CGEN_DONECODE */
  /* Generic and data table destruction */
  DONE;
  CDlpTable_DestroyInstance(_this->m_lpTable);
  _this->m_lpTable = NULL;

  /* Cancel pointer mappings */
  UNREMAP_FIELD("dim"   );
  UNREMAP_FIELD("nrec"  );
  UNREMAP_FIELD("maxrec");
  UNREMAP_FIELD("reclen");
  UNREMAP_FIELD("descr0");
  UNREMAP_FIELD("descr1");
  UNREMAP_FIELD("descr2");
  UNREMAP_FIELD("descr3");
  UNREMAP_FIELD("descr4");
  UNREMAP_FIELD("fsr"   );
  UNREMAP_FIELD("zf"    );
  UNREMAP_FIELD("ofs"   );
  UNREMAP_FIELD("rtext" );
  UNREMAP_FIELD("vrtext");
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CData_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	DEBUGMSG(-1,"CData_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("*{","",LPMF(CData,OnInitializeRecord),"Initialize one record from constants",0,"<int nRec> <data this>","... }")
	REGISTER_METHOD("-addcomp","-defcomp",LPMF(CData,OnAddComp),"Adds one component",0,"<string sName> <short nType> <data this>","")
	REGISTER_METHOD("-addncomps","-ndefcomp",LPMF(CData,OnAddNcomps),"Adds multiple components",0,"<short nType> <int nCount> <data this>","")
	REGISTER_METHOD("-aggregate","",LPMF(CData,OnAggregate),"Aggregates components/records/blocks",0,"<data dSrc> <data dMask> <complex dParam> <string sOpname> <data this>","")
	REGISTER_METHOD("-allocate","",LPMF(CData,OnAllocate),"Allocates and clears memory",0,"<int nRecs> <data this>","")
	REGISTER_METHOD("-array","",LPMF(CData,OnArray),"Defines components, allocates and clears memory",0,"<short nCType> <int nComps> <int nRecs> <data this>","{ ... }")
	REGISTER_METHOD("-cat","",LPMF(CData,OnCat),"Appends records",0,"<data iSrc> <data this>","")
	REGISTER_METHOD("-checksum","",LPMF(CData,OnChecksum),"Computates a checksum of the data",0,"<string sAlgo> <int nIc> <data this>","")
	REGISTER_METHOD("-clear","",LPMF(CData,OnClear),"Clears the data content",0,"<data this>","")
	REGISTER_METHOD("-compress","",LPMF(CData,OnCompress),"RLE compression of component nComp.",0,"<data idSrc> <int nComp> <data this>","")
	REGISTER_METHOD("-copy_cnames","",LPMF(CData,OnCopyCnames),"Copies selected component names",0,"<data iSrc> <int jx> <int jy> <int n> <data this>","")
	REGISTER_METHOD("-copy_descr","",LPMF(CData,OnCopyDescr),"Copies description fields",0,"<data idSrc> <data this>","")
	REGISTER_METHOD("-copy_labels","",LPMF(CData,OnCopyLabels),"Copies symbolic components",0,"<data iSrc> <data this>","")
	REGISTER_METHOD("-delete","",LPMF(CData,OnDelete),"Deletes components, records, blocks or marked elements",0,"<data idSrc> <int nFirst> <int nCount> <data this>","")
	REGISTER_METHOD("-dequantize","",LPMF(CData,OnDequantize),"Dequantization of numeric components.",0,"<data in> <data this>","")
	REGISTER_METHOD("-dfetch","",LPMF(CData,OnDfetch),"Fetches one numeric value",0,"<int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-dmark","",LPMF(CData,OnDmark),"Mark records/components/cells according to a table",0,"<data idMark> <data this>","")
	REGISTER_METHOD("-dstore","",LPMF(CData,OnDstore),"Stores one numeric value",0,"<double dVal> <int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-expand","",LPMF(CData,OnExpand),"RLE expansion",0,"<data idSrc> <int nIcE> <int nIcS> <int nIcL> <data this>","")
	REGISTER_METHOD("-fetch","",LPMF(CData,OnFetch),"Fetches one value.",0,"<int nIr> <comp> <data this>","")
	REGISTER_METHOD("-fill","",LPMF(CData,OnFill),"Fills numeric components",0,"<complex dStart> <complex dDelta> <data this>","")
	REGISTER_METHOD("-find_comp","",LPMF(CData,OnFindComp),"Gets the component index from a component name",0,"<string sCName> <data this>","")
	REGISTER_METHOD("-gen_index","",LPMF(CData,OnGenIndex),"Generates index by searching.",0,"<data idSrc> <data idTab> <int nSrcIdx> <int nTabIdx> <data this>","{ ... }")
	REGISTER_METHOD("-get_cname","",LPMF(CData,OnGetCname),"Gets the name of one component",0,"<int nIComp> <data this>","")
	REGISTER_METHOD("-get_cnames","",LPMF(CData,OnGetCnames),"Stores the component names into a table.",0,"<data idSrc> <data this>","")
	REGISTER_METHOD("-get_comp_type","",LPMF(CData,OnGetCompType),"Returns the variable type of a component",0,"<int nComp> <data this>","")
	REGISTER_METHOD("-init","",LPMF(CData,OnInitialize),"Initialize instance from constants",0,"<data this>","{ ... }")
	REGISTER_METHOD("-insertcomp","",LPMF(CData,OnInsertComp),"Inserts one component at a specified position",0,"<string sName> <short nType> <int nInsertAt> <data this>","")
	REGISTER_METHOD("-insertncomps","",LPMF(CData,OnInsertNcomps),"Inserts components at a specified position",0,"<short nType> <int nInsertAt> <int nCount> <data this>","")
	REGISTER_METHOD("-is_empty","",LPMF(CData,OnIsEmpty),"Returns TRUE if instance is empty",0,"<data this>","")
	REGISTER_METHOD("-join","",LPMF(CData,OnJoin),"Appends components",0,"<data iSrc> <data this>","")
	REGISTER_METHOD("-lookup","",LPMF(CData,OnLookup),"One dimensional table lookup.",0,"<data idSel> <int nIcSel> <data idTab> <int nIcTab> <int nCount> <data this>","{ ... }")
	REGISTER_METHOD("-lookup_2","",LPMF(CData,OnLookup2),"2-dim. lookup transformation",0,"<data sel1> <int j1> <data sel2> <int j2> <data tab> <data this>","{...}")
	REGISTER_METHOD("-mark","",LPMF(CData,OnMark),"Mark n records/blocks/components starting from jx.",0,"<int jx> <int n> <data this>","")
	REGISTER_METHOD("-pfetch","",LPMF(CData,OnPfetch),"Fetches one pointer",0,"<int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-print","",LPMF(CData,OnPrint),"Print data content",0,"<data this>","")
	REGISTER_METHOD("-pstore","",LPMF(CData,OnPstore),"Stores one pointer",0,"<ptr dVal> <int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-quantize","",LPMF(CData,OnQuantize),"Quantization of numeric components.",0,"<data idIn> <data this>","")
	REGISTER_METHOD("-reallocate","",LPMF(CData,OnReallocate),"Reallocates the memory preserving the contens.",0,"<int nRecs> <data this>","")
	REGISTER_METHOD("-repmat","",LPMF(CData,OnRepmat),"Replicate and tile a matrix.",0,"<data idSrc> <int nRecs> <int nComps> <data this>","")
	REGISTER_METHOD("-resample","",LPMF(CData,OnResample),"Resample with factor nRate > 0",0,"<data iSrc> <double nRate> <data this>","")
	REGISTER_METHOD("-reshape","",LPMF(CData,OnReshape),"Changes format of matrix (components/records)",0,"<data idSrc> <int nRecs> <int nComps> <data this>","")
	REGISTER_METHOD("-rindex","",LPMF(CData,OnRindex),"(Adds and) fills a component with the record index.",0,"<cstring sCname> <int nIc> <data this>","")
	REGISTER_METHOD("-rotate","",LPMF(CData,OnRotate),"Rotate n records/blocks/components.",0,"<data iSrc> <int nCount> <data this>","")
	REGISTER_METHOD("-scalop","",LPMF(CData,OnScalop),"Matrix-constant scalar operation",0,"<data idSrc> <complex nConst> <cstring sOpname> <data this>","")
	REGISTER_METHOD("-scalop_d","",LPMF(CData,OnScalopD),"Maxtrix-matrix scalar operation",0,"<data idSrc> <data idConst> <cstring sOpname> <data this>","")
	REGISTER_METHOD("-scopy","",LPMF(CData,OnScopy),"Copies the record structure",0,"<data idSrc> <data this>","")
	REGISTER_METHOD("-select","",LPMF(CData,OnSelect),"Copies components, records, blocks or marked elements",0,"<data idSrc> <int nFirst> <int nCount> <data this>","")
	REGISTER_METHOD("-set_cname","",LPMF(CData,OnSetCname),"Sets the name of one component",0,"<int nIComp> <string sCName> <data this>","")
	REGISTER_METHOD("-set_cnames","",LPMF(CData,OnSetCnames),"Sets component names from a table",0,"<data iTable> <int nIComp> <data this>","")
	REGISTER_METHOD("-sfetch","",LPMF(CData,OnSfetch),"Fetches one string",0,"<int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-shift","",LPMF(CData,OnShift),"Shift n records/blocks/components.",0,"<data iSrc> <int nCount> <data this>","")
	REGISTER_METHOD("-sortdown","",LPMF(CData,OnSortdown),"Sort data using comp. j as sort index in descending order.",0,"<data x> <int j> <data this>","")
	REGISTER_METHOD("-sortup","",LPMF(CData,OnSortup),"Sort data using comp. j as sort index in ascending order.",0,"<data x> <int j> <data this>","")
	REGISTER_METHOD("-sstore","",LPMF(CData,OnSstore),"Stores one string",0,"<string sVal> <int nIRec> <int nIComp> <data this>","")
	REGISTER_METHOD("-status","-descr",LPMF(CData,OnStatus),"Prints status information of the data instance.",0,"<data this>","")
	REGISTER_METHOD("-store","",LPMF(CData,OnStore),"Stores one value.",0,"<val> <int nIr> <comp> <data this>","")
	REGISTER_METHOD("-strop","",LPMF(CData,OnStrop),"Executes string operation y=op(x,s)",0,"<data iSrc> <string sParam> <string sOpname> <data this>","")
	REGISTER_METHOD("-tconvert","",LPMF(CData,OnTconvert),"Copies and convert numeric components",0,"<data idSrc> <short nCType> <data this>","")
	REGISTER_METHOD("-unmark","",LPMF(CData,OnUnmark),"Clear all markings.",0,"<data this>","")
	REGISTER_METHOD("-xfetch","",LPMF(CData,OnXfetch),"Fetches components, records or blocks.",0,"<first> <int nCount> <data this>","")
	REGISTER_METHOD("-xstore","",LPMF(CData,OnXstore),"Stores several components, records or blocks of a data           instance to another data instance at a specified position.",0,"<data idScr> <int nFirst> <int nCount> <pos> <data this>","")
	REGISTER_METHOD("[","",LPMF(CData,OnArrOp),"Array operator.",0,"<data this>","... ]")

	/* Register options */
	REGISTER_OPTION("/block","",LPMV(m_bBlock),NULL,"Block mode",0)
	REGISTER_OPTION("/cell","",LPMV(m_bCell),NULL,"Cell mode",0)
	REGISTER_OPTION("/comp","",LPMV(m_bComp),NULL,"Component mode",0)
	REGISTER_OPTION("/exact","",LPMV(m_bExact),NULL,"Generate noise",0)
	REGISTER_OPTION("/fast","",LPMV(m_bFast),NULL,"Use faster code (method dependend).",0)
	REGISTER_OPTION("/force","",LPMV(m_bForce),NULL,"Force operations (method dependend).",0)
	REGISTER_OPTION("/label","",LPMV(m_bLabel),NULL,"Ignore label indices if there some.",0)
	REGISTER_OPTION("/list","",LPMV(m_bList),NULL,"List mode.",0)
	REGISTER_OPTION("/mark","",LPMV(m_bMark),NULL,"switch to mark elements mode",0)
	REGISTER_OPTION("/matrix","",LPMV(m_bMatrix),NULL,"Matrix mode of 2 dim. lookup.",0)
	REGISTER_OPTION("/noise","",LPMV(m_bNoise),NULL,"Generate noise",0)
	REGISTER_OPTION("/numeric","",LPMV(m_bNumeric),NULL,"Sort strings numeric.",0)
	REGISTER_OPTION("/nz","",LPMV(m_bNz),NULL,"Print zeros as '-'",0)
	REGISTER_OPTION("/rec","",LPMV(m_bRec),NULL,"Record mode",0)

	/* Register fields */
	REGISTER_FIELD("cinc","",LPMV(m_nCinc),NULL,"Distance between subsequent components in physical units.",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("cofs","",LPMV(m_nCofs),NULL,"Offset of first component in physical units.",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("cunit","",LPMV(m_lpCunit),NULL,"Physical unit of component axis",0,10,10,"char[10]","")
	REGISTER_FIELD("descr0","",NULL,NULL,"User data description 0",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("descr1","",NULL,NULL,"User data description 1",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("descr2","",NULL,NULL,"User data description 2",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("descr3","",NULL,NULL,"User data description 3",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("descr4","",NULL,NULL,"User data description 4",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("dim","",NULL,NULL,"components per record",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("ftext","",LPMV(m_ftext),NULL,"File text",0,5001,1,"text",NULL)
	REGISTER_FIELD("lpTable","",LPMV(m_lpTable),NULL,"The data table",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"CDlpTable*",NULL)
	REGISTER_FIELD("mark_map","",LPMV(m_markMap),NULL,"Map used to mark elements.",FF_HIDDEN | FF_NOSET | FF_NOSAVE,5001,1,"text",NULL)
	REGISTER_FIELD("mark_map_size","",LPMV(m_markMapSize),NULL,"Size, i.e. number of elements in mark map.",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)0)
	REGISTER_FIELD("mark_mode","",LPMV(m_markMode),NULL,"Mode of marking elements.",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)0)
	REGISTER_FIELD("maxrec","",NULL,NULL,"max. number of records",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("nblock","",LPMV(m_nblock),NULL,"block number",0,2004,1,"int",(INT32)0)
	REGISTER_FIELD("noffset","",LPMV(m_noffset),NULL,"Record print Offset",0,2004,1,"int",(INT32)0)
	REGISTER_FIELD("nrec","",NULL,NULL,"Valid record number",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("reclen","",NULL,NULL,"record length [bytes]",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("rinc","fsr",NULL,NULL,"Distance between subsequent records in physical units.",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("rofs","ofs",NULL,NULL,"Offset of first record in physical units.",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("rtext","",NULL,NULL,"Realization text",0,5001,1,"text",NULL)
	REGISTER_FIELD("runit","",LPMV(m_lpRunit),NULL,"Physical unit of record axis.",0,10,10,"char[10]","ms")
	REGISTER_FIELD("rwid","zf",NULL,NULL,"Span width of one record in physical units.",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("vrtext","",NULL,NULL,"Realization description",0,5001,1,"text",NULL)
	REGISTER_FIELD("vunit","",LPMV(m_lpVunit),NULL,"Physical unit of values axis",0,10,10,"char[10]","")

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,DATA_INTERNAL,"Internal error (%s).")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,DATA_EMPTY,"Argument '%s' must not be empty.")
	REGISTER_ERROR("~e3_0_0__1",EL_ERROR,DATA_BADCOMP,"Component %d does not exist in instance '%s'.")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,DATA_BADCOMPTYPE,"Component %d in instance '%s' must be of type %s.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,DATA_BADOPC,"Opcode '%d' is not valid.")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,DATA_INITIALIZERS,"Too %s initializers follow '{'.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,DATA_BADINITIALIZER,"Bad initializer '%s' for element [%d,%d].")
	REGISTER_ERROR("~e8_0_0__1",EL_ERROR,DATA_HERESCAN,"Unexpected end of file (scanning for '%s').")
	REGISTER_ERROR("~e9_0_0__1",EL_ERROR,DATA_MTHINCOMPL,"Method not completed.")
	REGISTER_ERROR("~e0_1_0__1",EL_ERROR,DATA_OPCODE,"'%s' is not a valid %s operation.")
	REGISTER_ERROR("~e1_1_0__1",EL_ERROR,DATA_BADSORTMODE,"'%d' is not a valid mode for sort.")
	REGISTER_ERROR("~e2_1_0__1",EL_ERROR,DATA_BADSORTTYPE,"Component %d is of type '%s'. This type is not supported by sort.")
	REGISTER_ERROR("~e3_1_0__1",EL_WARNING,DATA_TRUNCATE,"Data truncate due to different number of %s in '%s' and '%s'.")
	REGISTER_ERROR("~e4_1_0__1",EL_WARNING,DATA_DIMMISMATCH,"Dimensions of %s and %s do not match (%s)!.")
	REGISTER_ERROR("~e5_1_0__1",EL_ERROR,DATA_NOMARK,"No %s marked in instance '%s'.")
	REGISTER_ERROR("~e6_1_0__1",EL_ERROR,DATA_BADMARK,"Processing marked %s is not supported.")
	REGISTER_ERROR("~e7_1_0__1",EL_ERROR,DATA_HOMOGEN,"Instance %s must be homogeneous (either numeric or symbolic components).")
	REGISTER_ERROR("~e8_1_0__1",EL_ERROR,DATA_DESERIALIZE,"Deserialization of instance '%s' failed%s.")
	REGISTER_ERROR("~e9_1_0__1",EL_ERROR,DATA_CNVT,"Cannot convert %s to %s.")
	REGISTER_ERROR("~e0_2_0__1",EL_ERROR,DATA_NOSUPPORT,"%s is not supported%s.")
	REGISTER_ERROR("~e1_2_0__1",EL_ERROR,DATA_MDIM,"Matrix dimension error%s.")
	REGISTER_ERROR("~e2_2_0__1",EL_ERROR,DATA_MDATA_WARN,"Matrix data error in block %ld%s.")
	REGISTER_ERROR("~e3_2_0__1",EL_ERROR,DATA_NOTFOUND_ERR,"%s%s not found.")
	REGISTER_ERROR("~e4_2_0__1",EL_ERROR,DATA_SIZE,"The data object has unexpected size of %s, must be %s %d.")
	REGISTER_ERROR("~e5_2_0__1",EL_WARNING,DATA_NOTFOUND,"%s%s not found.")
	REGISTER_ERROR("~e6_2_0__1",EL_WARNING,DATA_AMBIGUOUS,"Method ambiguous (%s).")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CData_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	DEBUGMSG(-1,"CData_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  /* Generic and data table initialization */
  INIT;
  _this->m_lpTable = CDlpTable_CreateInstance();
  if(!_this->m_lpTable) return NOT_EXEC;

  /* Remap fields */
  {
    /* Remap pointers to fields */
    REMAP_FIELD("dim"   , _this->m_lpTable->m_dim   );
    REMAP_FIELD("nrec"  , _this->m_lpTable->m_nrec  );
    REMAP_FIELD("maxrec", _this->m_lpTable->m_maxrec);
    REMAP_FIELD("reclen", _this->m_lpTable->m_reclen);
    REMAP_FIELD("descr0", _this->m_lpTable->m_descr0);
    REMAP_FIELD("descr1", _this->m_lpTable->m_descr1);
    REMAP_FIELD("descr2", _this->m_lpTable->m_descr2);
    REMAP_FIELD("descr3", _this->m_lpTable->m_descr3);
    REMAP_FIELD("descr4", _this->m_lpTable->m_descr4);
    REMAP_FIELD("rinc"  , _this->m_lpTable->m_fsr   );
    REMAP_FIELD("rwid"  , _this->m_lpTable->m_zf    );
    REMAP_FIELD("rofs"  , _this->m_lpTable->m_ofs   );
    REMAP_FIELD("rtext" , _this->m_lpTable->m_rtext );
    REMAP_FIELD("vrtext", _this->m_lpTable->m_vrtext);
  }

  /* Override XML serialization/deserialization methods */
  #ifndef __cplusplus
  __this->SerializeXml   = CData_SerializeXml;
  __this->DeserializeXml = CData_DeserializeXml;
  #endif
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CData_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	DEBUGMSG(-1,"CData_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  CDlpTable_Reset(_this->m_lpTable);
#ifndef __NORTTI
  RESET;
#endif
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CData_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CData_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
{
#ifdef CODE_DN3

#ifdef __NODN3STREAM

  return IERROR(_this,ERR_NOTSUPPORTED,  "-save (DNorm3 format)",0,0);

#else /* #ifdef __NODN3STREAM */

  hscan_t  hs;
  hnode_t* hn        = NULL;
  SWord*   lpWord    = NULL;
  char*    lpBuf     = NULL;
  char*    lpBuf2    = NULL;
  char*    lpVrtSave = NULL;
  INT16    nLimit    = 0;
  char     lpSep[2]  = { C_FIELDSEP, 0};
#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Serialization in __NORTTI mode",0,0);
#endif

  /* Data instances with complex components not supported to serialize */
  if(CData_GetNComplexComps(_this) > 0) {
    return IERROR(_this,ERR_NOTSUPPORTED,      "Serialization of data instances with complex components",0,0);
  }

  /* Empty data instances are not serialized */
  /* but registered using knr=0 and rnr=0 */
  if(CData_IsEmpty(_this))
  {
    /* Get current record in type information table */
    INT32 nTITIdx = CDlpTable_GetNRecs(lpDest->m_lpiTIT)-1;
    CDlpTable_Dstore(lpDest->m_lpiTIT,0,nTITIdx,OF_KNR);
    CDlpTable_Dstore(lpDest->m_lpiTIT,0,nTITIdx,OF_RNR);
    return O_K;
  }

  /* Serialize fields into realization string */
  lpBuf  = (char*)dlp_calloc(T_SHORT_MAX, sizeof(char));
  lpBuf2 = (char*)dlp_calloc(T_SHORT_MAX, sizeof(char));
  dlp_strcpy(lpBuf2,C_FIELDDEL);

  hash_scan_begin(&hs,BASEINST(_this)->m_lpDictionary);
  while ((hn = hash_scan_next(&hs)))
  {
    DLPASSERT((lpWord=(SWord*)hnode_get(hn))); /* NULL entry in dictionary */
    if (lpWord->nWordType == WL_TYPE_FIELD &&
        !(lpWord->nFlags & FF_NOSAVE) /* && !(lpWord->nFlags & FF_EXTERNAL) */)
    {
      CDlpObject_FieldToString(BASEINST(_this), lpBuf, T_SHORT_MAX, lpWord);
      dlp_strcat(lpBuf2,lpBuf); dlp_strcat(lpBuf2,lpSep);
    }
  }
  dlp_strcat(lpBuf2,C_FIELDDEL);

  if(_this->m_lpTable->m_rtext)
  {
    dlp_strncpy(lpBuf,_this->m_lpTable->m_rtext,T_SHORT_MAX);
    nLimit = T_SHORT_MAX-dlp_strlen(lpBuf)-1;
    lpBuf2[nLimit] = 0;
    dlp_strcat(lpBuf,lpBuf2);
  }
  else dlp_strcpy(lpBuf,lpBuf2);

  /* Save current vrtext */
  lpVrtSave = _this->m_lpTable->m_vrtext;

  /* Write serialized fields into realization attribute description string */
  _this->m_lpTable->m_vrtext = (char*)dlp_calloc(dlp_strlen(lpBuf)+1,sizeof(char));
  dlp_strcpy(_this->m_lpTable->m_vrtext,lpBuf);

  /* Serialize data table */
  if(O_K != CDN3Stream_SerializeTable(lpDest,_this->m_lpTable))
  {
    dlp_free(_this->m_lpTable->m_vrtext);
    _this->m_lpTable->m_vrtext = lpVrtSave;
    dlp_free(lpBuf);
    dlp_free(lpBuf2);
    return NOT_EXEC;
  }

  /* Restore current vrtext */
  dlp_free(_this->m_lpTable->m_vrtext);
  _this->m_lpTable->m_vrtext = lpVrtSave;

  /* Clean up */
  dlp_free(lpBuf);
  dlp_free(lpBuf2);

  DLP_CHECK_MEMINTEGRITY
  return O_K;

#endif /* #ifdef __NODN3STREAM */

#endif /* #ifdef CODE_DN3 */
#ifdef CODE_XML

#ifndef __NOXMLSTREAM

  INT16 nRet = O_K;
  char  lpFqName[255];

#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Serialization in __NORTTI mode",0,0);
#endif
  GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);

  /* Invoke base class */
  IF_NOK((nRet=INVOKE_BASEINST_1(SerializeXml,lpDest))) return nRet;

  /* Serialize data table */
  /* - Get fully qualified table name
       - trim root instance name
       - append ".<table>"
  */
  CDlpObject_GetFQName(BASEINST(_this),lpFqName,TRUE);
  while (*lpFqName && *lpFqName!='.') dlp_memmove(lpFqName,&lpFqName[1],dlp_strlen(lpFqName));
  if (*lpFqName=='.') dlp_memmove(lpFqName,&lpFqName[1],dlp_strlen(lpFqName));
  dlp_strcat(lpFqName,".~table");

  /* - Do serialize table */
  IF_NOK((nRet=CXmlStream_SerializeTable(lpDest,_this->m_lpTable,lpFqName))) return nRet;

  return O_K;

#else /* #ifndef __NOXMLSTREAM */

  return NOT_EXEC;

#endif /* #ifndef __NOXMLSTREAM */

#endif /* #ifdef CODE_XML */
}
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CData_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
{
#ifdef CODE_DN3

#ifdef __NODN3STREAM

  return IERROR(_this,ERR_NOTSUPPORTED,  "-save (DNorm3 format)",0,0);

#else /* #ifdef __NODN3STREAM */

  hscan_t  hs;
  hnode_t* hn        = NULL;
  SWord*   lpWord    = NULL;
  char*    lpBuf     = NULL;
  char*    lpBuf2    = NULL;
  char*    lpVrtSave = NULL;
  INT16    nLimit    = 0;
  char     lpSep[2]  = { C_FIELDSEP, 0};
#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Serialization in __NORTTI mode",0,0);
#endif

  /* Data instances with complex components not supported to serialize */
  if(CData_GetNComplexComps(_this) > 0) {
    return IERROR(_this,ERR_NOTSUPPORTED,      "Serialization of data instances with complex components",0,0);
  }

  /* Empty data instances are not serialized */
  /* but registered using knr=0 and rnr=0 */
  if(CData_IsEmpty(_this))
  {
    /* Get current record in type information table */
    INT32 nTITIdx = CDlpTable_GetNRecs(lpDest->m_lpiTIT)-1;
    CDlpTable_Dstore(lpDest->m_lpiTIT,0,nTITIdx,OF_KNR);
    CDlpTable_Dstore(lpDest->m_lpiTIT,0,nTITIdx,OF_RNR);
    return O_K;
  }

  /* Serialize fields into realization string */
  lpBuf  = (char*)dlp_calloc(T_SHORT_MAX, sizeof(char));
  lpBuf2 = (char*)dlp_calloc(T_SHORT_MAX, sizeof(char));
  dlp_strcpy(lpBuf2,C_FIELDDEL);

  hash_scan_begin(&hs,BASEINST(_this)->m_lpDictionary);
  while ((hn = hash_scan_next(&hs)))
  {
    DLPASSERT((lpWord=(SWord*)hnode_get(hn))); /* NULL entry in dictionary */
    if (lpWord->nWordType == WL_TYPE_FIELD &&
        !(lpWord->nFlags & FF_NOSAVE) /* && !(lpWord->nFlags & FF_EXTERNAL) */)
    {
      CDlpObject_FieldToString(BASEINST(_this), lpBuf, T_SHORT_MAX, lpWord);
      dlp_strcat(lpBuf2,lpBuf); dlp_strcat(lpBuf2,lpSep);
    }
  }
  dlp_strcat(lpBuf2,C_FIELDDEL);

  if(_this->m_lpTable->m_rtext)
  {
    dlp_strncpy(lpBuf,_this->m_lpTable->m_rtext,T_SHORT_MAX);
    nLimit = T_SHORT_MAX-dlp_strlen(lpBuf)-1;
    lpBuf2[nLimit] = 0;
    dlp_strcat(lpBuf,lpBuf2);
  }
  else dlp_strcpy(lpBuf,lpBuf2);

  /* Save current vrtext */
  lpVrtSave = _this->m_lpTable->m_vrtext;

  /* Write serialized fields into realization attribute description string */
  _this->m_lpTable->m_vrtext = (char*)dlp_calloc(dlp_strlen(lpBuf)+1,sizeof(char));
  dlp_strcpy(_this->m_lpTable->m_vrtext,lpBuf);

  /* Serialize data table */
  if(O_K != CDN3Stream_SerializeTable(lpDest,_this->m_lpTable))
  {
    dlp_free(_this->m_lpTable->m_vrtext);
    _this->m_lpTable->m_vrtext = lpVrtSave;
    dlp_free(lpBuf);
    dlp_free(lpBuf2);
    return NOT_EXEC;
  }

  /* Restore current vrtext */
  dlp_free(_this->m_lpTable->m_vrtext);
  _this->m_lpTable->m_vrtext = lpVrtSave;

  /* Clean up */
  dlp_free(lpBuf);
  dlp_free(lpBuf2);

  DLP_CHECK_MEMINTEGRITY
  return O_K;

#endif /* #ifdef __NODN3STREAM */

#endif /* #ifdef CODE_DN3 */
#ifdef CODE_XML

#ifndef __NOXMLSTREAM

  INT16 nRet = O_K;
  char  lpFqName[255];

#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Serialization in __NORTTI mode",0,0);
#endif
  GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);

  /* Invoke base class */
  IF_NOK((nRet=INVOKE_BASEINST_1(SerializeXml,lpDest))) return nRet;

  /* Serialize data table */
  /* - Get fully qualified table name
       - trim root instance name
       - append ".<table>"
  */
  CDlpObject_GetFQName(BASEINST(_this),lpFqName,TRUE);
  while (*lpFqName && *lpFqName!='.') dlp_memmove(lpFqName,&lpFqName[1],dlp_strlen(lpFqName));
  if (*lpFqName=='.') dlp_memmove(lpFqName,&lpFqName[1],dlp_strlen(lpFqName));
  dlp_strcat(lpFqName,".~table");

  /* - Do serialize table */
  IF_NOK((nRet=CXmlStream_SerializeTable(lpDest,_this->m_lpTable,lpFqName))) return nRet;

  return O_K;

#else /* #ifndef __NOXMLSTREAM */

  return NOT_EXEC;

#endif /* #ifndef __NOXMLSTREAM */

#endif /* #ifdef CODE_XML */
}
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CData_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
{
#ifdef CODE_DN3

#ifdef __NODN3STREAM

  return IERROR(_this,ERR_NOTSUPPORTED,  "-restore (DNorm3 format)",0,0);

#else /* #ifdef __NODN3STREAM */

  hscan_t  hs;
  hnode_t* hn     = NULL;
  SWord*   lpWord = NULL;
  INT16    nErr   = O_K;
#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Deserialization in __NORTTI mode",0,0);
#endif

  /* Empty tables marked by knr=0 and rnr=0 --> skip, no error */
  if (lpSrc->m_nKnr==0 && lpSrc->m_nRnr==0) return O_K;

  /* Deserialize data table */
  nErr = CDN3Stream_DeserializeTable(lpSrc, _this->m_lpTable);
  IF_NOK(nErr)
  {
    if (nErr==-2)
    {
      IERROR(_this,DATA_DESERIALIZE,BASEINST(_this)->m_lpInstanceName,   " (out of memory)",0);
      return NOT_EXEC;
    }
    IERROR(_this,DATA_DESERIALIZE,BASEINST(_this)->m_lpInstanceName,"",0);
    return NOT_EXEC;
  }

  /* Deserialize fields from realization string */
  if(_this->m_lpTable->m_vrtext)
  {
    /* Move deserialized vrtext to a buffer */
    char* lpBuf = _this->m_lpTable->m_vrtext;
    _this->m_lpTable->m_vrtext = NULL;

    /* Deserialize fields from former vrtext (including the vrtext itself) */
    hash_scan_begin(&hs,BASEINST(_this)->m_lpDictionary);
    while ((hn = hash_scan_next(&hs)))
    {
      DLPASSERT((lpWord=(SWord*)hnode_get(hn))); /* NULL entry in dictionary */
      if(lpWord->nWordType == WL_TYPE_FIELD &&
         !(lpWord->nFlags & FF_NOSAVE) /* && !(lpWord->nFlags & FF_EXTERNAL) */)
      {
        CDlpObject_FieldFromString(BASEINST(_this),lpWord,lpBuf);
      }
    }

    /* Delete former crtext */
    dlp_free(lpBuf);
  }

  DLP_CHECK_MEMINTEGRITY
  return O_K;

#endif /* #ifdef __NODN3STREAM */

#endif /* #ifdef CODE_DN3 */
#ifdef CODE_XML

#ifndef __NOXMLSTREAM

  INT16       nRet = O_K;
  SDomObject* lpDo = NULL;
  char        lpFqName[255];
  INT32        nRootInameLen   = 0;
  INT32        nInameLen       = 0;

#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Deserialization in __NORTTI mode",0,0);
#endif
  GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);

  /* Invoke base class */
  IF_NOK((nRet=INVOKE_BASEINST_1(DeserializeXml,lpSrc))) return nRet;

  /* Set fully qualified name of root instance if blank */
  if(lpSrc->m_lpsRootInameFq[0]=='\0') CDlpObject_GetFQName(BASEINST(_this),lpSrc->m_lpsRootInameFq,TRUE);

  /* Get fully qualified table name
     - trim root instance name
     - append ".<table>"
  */
  CDlpObject_GetFQName(BASEINST(_this),lpFqName,TRUE);
  dlp_strcat(lpFqName,".~table");

  /* Cut root instance name from instance name */
  nRootInameLen=dlp_strlen(lpSrc->m_lpsRootInameFq);
  nInameLen=dlp_strlen(lpFqName);
  if(dlp_strncmp(lpFqName,lpSrc->m_lpsRootInameFq,nRootInameLen)){
    IFCHECK printf(        " *** Root instance name doesnt match *** ");
    IERROR(_this,ERR_DESERIALIZE,lpFqName,0,0);
    return O_K;
  }
  dlp_memmove(lpFqName,lpFqName+nRootInameLen,nInameLen-nRootInameLen+1);

   /* Deserialize data table */
  lpDo = CXmlStream_FindObject(lpSrc,lpFqName);
  if (!lpDo || lpDo->nType!=XMLS_DT_TABLE || !lpDo->lpValue)
  {
    CXmlStream_ObjectNotFound(lpSrc);
    return IERROR(_this,ERR_STREAMOBJ,lpFqName,0,0);
  }

  /* NOTE: Must not copy pointer because of remapped fields! */
	CDlpTable_Dcopy((CDlpTable*)lpDo->lpValue,_this->m_lpTable);
	CDlpTable_Copy(_this->m_lpTable,(CDlpTable*)lpDo->lpValue,0,((CDlpTable*)lpDo->lpValue)->m_nrec);

  return O_K;

#else /* #ifndef __NOXMLSTREAM */

  return NOT_EXEC;

#endif /* #ifndef __NOXMLSTREAM */

#endif /* #ifdef CODE_XML */
}
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CData_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
{
#ifdef CODE_DN3

#ifdef __NODN3STREAM

  return IERROR(_this,ERR_NOTSUPPORTED,  "-restore (DNorm3 format)",0,0);

#else /* #ifdef __NODN3STREAM */

  hscan_t  hs;
  hnode_t* hn     = NULL;
  SWord*   lpWord = NULL;
  INT16    nErr   = O_K;
#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Deserialization in __NORTTI mode",0,0);
#endif

  /* Empty tables marked by knr=0 and rnr=0 --> skip, no error */
  if (lpSrc->m_nKnr==0 && lpSrc->m_nRnr==0) return O_K;

  /* Deserialize data table */
  nErr = CDN3Stream_DeserializeTable(lpSrc, _this->m_lpTable);
  IF_NOK(nErr)
  {
    if (nErr==-2)
    {
      IERROR(_this,DATA_DESERIALIZE,BASEINST(_this)->m_lpInstanceName,   " (out of memory)",0);
      return NOT_EXEC;
    }
    IERROR(_this,DATA_DESERIALIZE,BASEINST(_this)->m_lpInstanceName,"",0);
    return NOT_EXEC;
  }

  /* Deserialize fields from realization string */
  if(_this->m_lpTable->m_vrtext)
  {
    /* Move deserialized vrtext to a buffer */
    char* lpBuf = _this->m_lpTable->m_vrtext;
    _this->m_lpTable->m_vrtext = NULL;

    /* Deserialize fields from former vrtext (including the vrtext itself) */
    hash_scan_begin(&hs,BASEINST(_this)->m_lpDictionary);
    while ((hn = hash_scan_next(&hs)))
    {
      DLPASSERT((lpWord=(SWord*)hnode_get(hn))); /* NULL entry in dictionary */
      if(lpWord->nWordType == WL_TYPE_FIELD &&
         !(lpWord->nFlags & FF_NOSAVE) /* && !(lpWord->nFlags & FF_EXTERNAL) */)
      {
        CDlpObject_FieldFromString(BASEINST(_this),lpWord,lpBuf);
      }
    }

    /* Delete former crtext */
    dlp_free(lpBuf);
  }

  DLP_CHECK_MEMINTEGRITY
  return O_K;

#endif /* #ifdef __NODN3STREAM */

#endif /* #ifdef CODE_DN3 */
#ifdef CODE_XML

#ifndef __NOXMLSTREAM

  INT16       nRet = O_K;
  SDomObject* lpDo = NULL;
  char        lpFqName[255];
  INT32        nRootInameLen   = 0;
  INT32        nInameLen       = 0;

#ifdef __NORTTI
  return IERROR(_this,ERR_NOTSUPPORTED,   "Deserialization in __NORTTI mode",0,0);
#endif
  GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);

  /* Invoke base class */
  IF_NOK((nRet=INVOKE_BASEINST_1(DeserializeXml,lpSrc))) return nRet;

  /* Set fully qualified name of root instance if blank */
  if(lpSrc->m_lpsRootInameFq[0]=='\0') CDlpObject_GetFQName(BASEINST(_this),lpSrc->m_lpsRootInameFq,TRUE);

  /* Get fully qualified table name
     - trim root instance name
     - append ".<table>"
  */
  CDlpObject_GetFQName(BASEINST(_this),lpFqName,TRUE);
  dlp_strcat(lpFqName,".~table");

  /* Cut root instance name from instance name */
  nRootInameLen=dlp_strlen(lpSrc->m_lpsRootInameFq);
  nInameLen=dlp_strlen(lpFqName);
  if(dlp_strncmp(lpFqName,lpSrc->m_lpsRootInameFq,nRootInameLen)){
    IFCHECK printf(        " *** Root instance name doesnt match *** ");
    IERROR(_this,ERR_DESERIALIZE,lpFqName,0,0);
    return O_K;
  }
  dlp_memmove(lpFqName,lpFqName+nRootInameLen,nInameLen-nRootInameLen+1);

   /* Deserialize data table */
  lpDo = CXmlStream_FindObject(lpSrc,lpFqName);
  if (!lpDo || lpDo->nType!=XMLS_DT_TABLE || !lpDo->lpValue)
  {
    CXmlStream_ObjectNotFound(lpSrc);
    return IERROR(_this,ERR_STREAMOBJ,lpFqName,0,0);
  }

  /* NOTE: Must not copy pointer because of remapped fields! */
	CDlpTable_Dcopy((CDlpTable*)lpDo->lpValue,_this->m_lpTable);
	CDlpTable_Copy(_this->m_lpTable,(CDlpTable*)lpDo->lpValue,0,((CDlpTable*)lpDo->lpValue)->m_nrec);

  return O_K;

#else /* #ifndef __NOXMLSTREAM */

  return NOT_EXEC;

#endif /* #ifndef __NOXMLSTREAM */

#endif /* #ifdef CODE_XML */
}
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CData_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
{
  /* Get type save pointer to source */
  data* iSrc = NULL;
  GET_VIRTUAL_RV(iSrc,CData,__iSrc,NOT_EXEC);

  /* Call generic instance copy method */
  COPY;

  /* Copy data table (must be done AFTER copying fields!) */
  if(O_K != CDlpTable_Copy(_this->m_lpTable, iSrc->m_lpTable, 0, iSrc->m_lpTable->m_nrec)) return NOT_EXEC;
}
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CData_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CData* CData_CreateInstance(const char* lpName)
{
	CData* lpNewInstance;
	ICREATEEX(CData,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CData_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CData::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CData::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CData_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CData_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "Data";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Generic data container";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CData";
	lpClassWord->ex.fct.lpAuthor    = "g. strecha, dresden";

	dlp_strcpy(lpClassWord->lpName             ,"data");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"2.0.1");

	return O_K;
}

INT16 CData_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CData_GetClassInfo(lpClassWord);
}

BOOL CData_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"data",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CData_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	DEBUGMSG(-1,"CData_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bBlock = FALSE;
	_this->m_bCell = FALSE;
	_this->m_bComp = FALSE;
	_this->m_bExact = FALSE;
	_this->m_bFast = FALSE;
	_this->m_bForce = FALSE;
	_this->m_bLabel = FALSE;
	_this->m_bList = FALSE;
	_this->m_bMark = FALSE;
	_this->m_bMatrix = FALSE;
	_this->m_bNoise = FALSE;
	_this->m_bNumeric = FALSE;
	_this->m_bNz = FALSE;
	_this->m_bRec = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CData_OnInitializeRecord(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nRec;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nRec = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_InitializeRecord(_this, nRec);
	return __nErr;
}

INT16 CData_OnAddComp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sName;
	INT16 nType;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nType = (INT16)MIC_GET_N(1,0);
	sName = MIC_GET_S(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_AddComp(_this, sName, nType);
	return __nErr;
}

INT16 CData_OnAddNcomps(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT16 nType;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nType = (INT16)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_AddNcomps(_this, nType, nCount);
	return __nErr;
}

INT16 CData_OnAggregate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* dSrc;
	data* dMask;
	COMPLEX64 dParam;
	char* sOpname;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sOpname = MIC_GET_S(1,0);
	dParam = MIC_GET_C(2,0);
	dMask = MIC_GET_I_EX(dMask,data,3,1);
	dSrc = MIC_GET_I_EX(dSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Aggregate(_this, dSrc, dMask, dParam, sOpname);
	return __nErr;
}

INT16 CData_OnAllocate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nRecs;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nRecs = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Allocate(_this, nRecs);
	return __nErr;
}

INT16 CData_OnArray(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT16 nCType;
	INT32 nComps;
	INT32 nRecs;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nRecs = (INT32)MIC_GET_N(1,0);
	nComps = (INT32)MIC_GET_N(2,1);
	nCType = (INT16)MIC_GET_N(3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Array(_this, nCType, nComps, nRecs);
	return __nErr;
}

INT16 CData_OnCat(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iSrc = MIC_GET_I_EX(iSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Cat(_this, iSrc);
	return __nErr;
}

INT16 CData_OnChecksum(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sAlgo;
	INT32 nIc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIc = (INT32)MIC_GET_N(1,0);
	sAlgo = MIC_GET_S(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Checksum(_this, sAlgo, nIc);
	return __nErr;
}

INT16 CData_OnClear(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Clear(_this);
	return __nErr;
}

INT16 CData_OnCompress(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nComp = (INT32)MIC_GET_N(1,0);
	idSrc = MIC_GET_I_EX(idSrc,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Compress(_this, idSrc, nComp);
	return __nErr;
}

INT16 CData_OnCopyCnames(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	INT32 jx;
	INT32 jy;
	INT32 n;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	n = (INT32)MIC_GET_N(1,0);
	jy = (INT32)MIC_GET_N(2,1);
	jx = (INT32)MIC_GET_N(3,2);
	iSrc = MIC_GET_I_EX(iSrc,data,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_CopyCnames(_this, iSrc, jx, jy, n);
	return __nErr;
}

INT16 CData_OnCopyDescr(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idSrc = MIC_GET_I_EX(idSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_CopyDescr(_this, idSrc);
	return __nErr;
}

INT16 CData_OnCopyLabels(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iSrc = MIC_GET_I_EX(iSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_CopyLabels(_this, iSrc);
	return __nErr;
}

INT16 CData_OnDelete(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nFirst;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nFirst = (INT32)MIC_GET_N(2,1);
	idSrc = MIC_GET_I_EX(idSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Delete(_this, idSrc, nFirst, nCount);
	return __nErr;
}

INT16 CData_OnDequantize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* in;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	in = MIC_GET_I_EX(in,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Dequantize(_this, in);
	return __nErr;
}

INT16 CData_OnDfetch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CData_Dfetch(_this, nIRec, nIComp));
	return __nErr;
}

INT16 CData_OnDmark(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idMark;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idMark = MIC_GET_I_EX(idMark,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Dmark(_this, idMark);
	return __nErr;
}

INT16 CData_OnDstore(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	FLOAT64 dVal;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	dVal = MIC_GET_N(3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Dstore(_this, dVal, nIRec, nIComp);
	return __nErr;
}

INT16 CData_OnExpand(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nIcE;
	INT32 nIcS;
	INT32 nIcL;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIcL = (INT32)MIC_GET_N(1,0);
	nIcS = (INT32)MIC_GET_N(2,1);
	nIcE = (INT32)MIC_GET_N(3,2);
	idSrc = MIC_GET_I_EX(idSrc,data,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Expand(_this, idSrc, nIcE, nIcS, nIcL);
	return __nErr;
}

INT16 CData_OnFetch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
    INT32 nIr;
    INT32 nIc;
    GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
    MIC_CHECK;
    /*nIc = (INT32)MIC_GET_N(1,0);*/
    nIc = CData_MicGetIc(_this,1,0);
    nIr = (INT32)MIC_GET_N(2,1);
    if (dlp_is_numeric_type_code(CData_GetCompType(_this,nIc)))
      MIC_PUT_C(CData_Cfetch(_this,nIr,nIc));
    else
      MIC_PUT_S(CData_Sfetch(_this,nIr,nIc));
    return O_K;
/* <-- User defined code */
}

INT16 CData_OnFill(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	COMPLEX64 dStart;
	COMPLEX64 dDelta;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	dDelta = MIC_GET_C(1,0);
	dStart = MIC_GET_C(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Fill(_this, dStart, dDelta);
	return __nErr;
}

INT16 CData_OnFindComp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sCName;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sCName = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CData_FindComp(_this, sCName));
	return __nErr;
}

INT16 CData_OnGenIndex(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	data* idTab;
	INT32 nSrcIdx;
	INT32 nTabIdx;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nTabIdx = (INT32)MIC_GET_N(1,0);
	nSrcIdx = (INT32)MIC_GET_N(2,1);
	idTab = MIC_GET_I_EX(idTab,data,3,1);
	idSrc = MIC_GET_I_EX(idSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_GenIndex(_this, idSrc, idTab, nSrcIdx, nTabIdx);
	return __nErr;
}

INT16 CData_OnGetCname(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S(CData_GetCname(_this, nIComp));
	return __nErr;
}

INT16 CData_OnGetCnames(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idSrc = MIC_GET_I_EX(idSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_GetCnames(_this, idSrc);
	return __nErr;
}

INT16 CData_OnGetCompType(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nComp = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CData_GetCompType(_this, nComp));
	return __nErr;
}

INT16 CData_OnInitialize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Initialize(_this);
	return __nErr;
}

INT16 CData_OnInsertComp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sName;
	INT16 nType;
	INT32 nInsertAt;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nInsertAt = (INT32)MIC_GET_N(1,0);
	nType = (INT16)MIC_GET_N(2,1);
	sName = MIC_GET_S(3,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_InsertComp(_this, sName, nType, nInsertAt);
	return __nErr;
}

INT16 CData_OnInsertNcomps(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT16 nType;
	INT32 nInsertAt;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nInsertAt = (INT32)MIC_GET_N(2,1);
	nType = (INT16)MIC_GET_N(3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_InsertNcomps(_this, nType, nInsertAt, nCount);
	return __nErr;
}

INT16 CData_OnIsEmpty(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CData_IsEmpty(_this));
	return __nErr;
}

INT16 CData_OnJoin(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iSrc = MIC_GET_I_EX(iSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Join(_this, iSrc);
	return __nErr;
}

INT16 CData_OnLookup(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSel;
	INT32 nIcSel;
	data* idTab;
	INT32 nIcTab;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nIcTab = (INT32)MIC_GET_N(2,1);
	idTab = MIC_GET_I_EX(idTab,data,3,1);
	nIcSel = (INT32)MIC_GET_N(4,2);
	idSel = MIC_GET_I_EX(idSel,data,5,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Lookup(_this, idSel, nIcSel, idTab, nIcTab, nCount);
	return __nErr;
}

INT16 CData_OnLookup2(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* sel1;
	INT32 j1;
	data* sel2;
	INT32 j2;
	data* tab;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	tab = MIC_GET_I_EX(tab,data,1,1);
	j2 = (INT32)MIC_GET_N(2,0);
	sel2 = MIC_GET_I_EX(sel2,data,3,2);
	j1 = (INT32)MIC_GET_N(4,1);
	sel1 = MIC_GET_I_EX(sel1,data,5,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Lookup2(_this, sel1, j1, sel2, j2, tab);
	return __nErr;
}

INT16 CData_OnMark(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 jx;
	INT32 n;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	n = (INT32)MIC_GET_N(1,0);
	jx = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Mark(_this, jx, n);
	return __nErr;
}

INT16 CData_OnPfetch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S((const char*)CData_Pfetch(_this, nIRec, nIComp));
	return __nErr;
}

INT16 CData_OnPrint(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Print(_this);
	return __nErr;
}

INT16 CData_OnPstore(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	void* dVal;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	dVal = MIC_GET_S(3,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Pstore(_this, dVal, nIRec, nIComp);
	return __nErr;
}

INT16 CData_OnQuantize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idIn;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idIn = MIC_GET_I_EX(idIn,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Quantize(_this, idIn);
	return __nErr;
}

INT16 CData_OnReallocate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nRecs;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nRecs = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Reallocate(_this, nRecs);
	return __nErr;
}

INT16 CData_OnRepmat(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nRecs;
	INT32 nComps;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nComps = (INT32)MIC_GET_N(1,0);
	nRecs = (INT32)MIC_GET_N(2,1);
	idSrc = MIC_GET_I_EX(idSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Repmat(_this, idSrc, nRecs, nComps);
	return __nErr;
}

INT16 CData_OnResample(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	FLOAT64 nRate;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nRate = MIC_GET_N(1,0);
	iSrc = MIC_GET_I_EX(iSrc,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Resample(_this, iSrc, nRate);
	return __nErr;
}

INT16 CData_OnReshape(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nRecs;
	INT32 nComps;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nComps = (INT32)MIC_GET_N(1,0);
	nRecs = (INT32)MIC_GET_N(2,1);
	idSrc = MIC_GET_I_EX(idSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Reshape(_this, idSrc, nRecs, nComps);
	return __nErr;
}

INT16 CData_OnRindex(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	const char* sCname;
	INT32 nIc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIc = (INT32)MIC_GET_N(1,0);
	sCname = MIC_GET_S(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Rindex(_this, sCname, nIc);
	return __nErr;
}

INT16 CData_OnRotate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	iSrc = MIC_GET_I_EX(iSrc,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Rotate(_this, iSrc, nCount);
	return __nErr;
}

INT16 CData_OnScalop(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	COMPLEX64 nConst;
	const char* sOpname;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sOpname = MIC_GET_S(1,0);
	nConst = MIC_GET_C(2,0);
	idSrc = MIC_GET_I_EX(idSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Scalop(_this, idSrc, nConst, sOpname);
	return __nErr;
}

INT16 CData_OnScalopD(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	data* idConst;
	const char* sOpname;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sOpname = MIC_GET_S(1,0);
	idConst = MIC_GET_I_EX(idConst,data,2,1);
	idSrc = MIC_GET_I_EX(idSrc,data,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_ScalopD(_this, idSrc, idConst, sOpname);
	return __nErr;
}

INT16 CData_OnScopy(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idSrc = MIC_GET_I_EX(idSrc,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Scopy(_this, idSrc);
	return __nErr;
}

INT16 CData_OnSelect(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nFirst;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nFirst = (INT32)MIC_GET_N(2,1);
	idSrc = MIC_GET_I_EX(idSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Select(_this, idSrc, nFirst, nCount);
	return __nErr;
}

INT16 CData_OnSetCname(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nIComp;
	char* sCName;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sCName = MIC_GET_S(1,0);
	nIComp = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_SetCname(_this, nIComp, sCName);
	return __nErr;
}

INT16 CData_OnSetCnames(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iTable;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	iTable = MIC_GET_I_EX(iTable,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_SetCnames(_this, iTable, nIComp);
	return __nErr;
}

INT16 CData_OnSfetch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S(CData_Sfetch(_this, nIRec, nIComp));
	return __nErr;
}

INT16 CData_OnShift(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	iSrc = MIC_GET_I_EX(iSrc,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Shift(_this, iSrc, nCount);
	return __nErr;
}

INT16 CData_OnSortdown(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* x;
	INT32 j;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	j = (INT32)MIC_GET_N(1,0);
	x = MIC_GET_I_EX(x,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Sortdown(_this, x, j);
	return __nErr;
}

INT16 CData_OnSortup(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* x;
	INT32 j;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	j = (INT32)MIC_GET_N(1,0);
	x = MIC_GET_I_EX(x,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Sortup(_this, x, j);
	return __nErr;
}

INT16 CData_OnSstore(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sVal;
	INT32 nIRec;
	INT32 nIComp;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nIComp = (INT32)MIC_GET_N(1,0);
	nIRec = (INT32)MIC_GET_N(2,1);
	sVal = MIC_GET_S(3,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Sstore(_this, sVal, nIRec, nIComp);
	return __nErr;
}

INT16 CData_OnStatus(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Status(_this);
	return __nErr;
}

INT16 CData_OnStore(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
    INT32 nIr;
    INT32 nIc;
    GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
    MIC_CHECK;
    /*nIc = (INT32)MIC_GET_N(1,0);*/
    nIc = CData_MicGetIc(_this,1,0);
    nIr = (INT32)MIC_GET_N(2,1);
    if (dlp_is_numeric_type_code(CData_GetCompType(_this,nIc)))
      return CData_Cstore(_this,MIC_GET_C(3,2),nIr,nIc);
    else if (dlp_is_symbolic_type_code(CData_GetCompType(_this,nIc)))
      return CData_Sstore(_this,MIC_GET_S(3,2),nIr,nIc);
    else if (dlp_is_pointer_type_code(CData_GetCompType(_this,nIc)))
      return CData_Pstore(_this,MIC_GET_I(3,2),nIr,nIc);
    return NOT_EXEC;
/* <-- User defined code */
}

INT16 CData_OnStrop(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* iSrc;
	char* sParam;
	char* sOpname;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sOpname = MIC_GET_S(1,0);
	sParam = MIC_GET_S(2,1);
	iSrc = MIC_GET_I_EX(iSrc,data,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Strop(_this, iSrc, sParam, sOpname);
	return __nErr;
}

INT16 CData_OnTconvert(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT16 nCType;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCType = (INT16)MIC_GET_N(1,0);
	idSrc = MIC_GET_I_EX(idSrc,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Tconvert(_this, idSrc, nCType);
	return __nErr;
}

INT16 CData_OnUnmark(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_Unmark(_this);
	return __nErr;
}

INT16 CData_OnXfetch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
    INT16 __nErr = O_K;
    INT32 nFirst;
    INT32 nCount;
    GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
    MIC_CHECK;
    nCount = (INT32)MIC_GET_N(1,0);
    nFirst = CData_MicGetIc(_this,2,1);
    /*nFirst = (INT32)MIC_GET_N(2,1); */
    __nErr = CData_Xfetch(_this, nFirst, nCount);
    return __nErr;
/* <-- User defined code */
}

INT16 CData_OnXstore(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
/* User defined code --> */
    INT16 __nErr = O_K;
    data* idScr;
    INT32 nFirst;
    INT32 nCount;
    INT32 nPos;
    GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
    MIC_CHECK;
    /*nPos = (INT32)MIC_GET_N(1,0);*/
    nPos = CData_MicGetIc(_this,1,0);
    nCount = (INT32)MIC_GET_N(2,1);
    nFirst = (INT32)MIC_GET_N(3,2);
    idScr = MIC_GET_I_EX(idScr,data,4,1);
    __nErr = CData_Xstore(_this, idScr, nFirst, nCount, nPos);
    return __nErr;
/* <-- User defined code */
}

INT16 CData_OnArrOp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CData,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CData_ArrOp(_this);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CData_Checksum(CData* _this, char* sAlgo, INT32 nIc)
{
  #ifndef __NODLPMATH
    INT32 nCheckSum=CData_ChecksumInt(_this,sAlgo,nIc);
    MIC_PUT_N(nCheckSum);
  #else
    IERROR(_this,ERR_NOTSUPPORTED,    "Method -checksum in __NODLPMATH mode",0,0);
  #endif /* #ifndef __NODLPMATH */
	return O_K;
}

INT16 CData_Reallocate(CData* _this, INT32 nRecs)
{
    CData_Realloc(_this,nRecs);
    CData_IncNRecs(_this,nRecs-CData_GetNRecs(_this));
	return O_K;
}

INT16 CData_Resample(CData* _this, data* iSrc, FLOAT64 nRate)
{
    CData_ResampleInt(_this, iSrc, nRate, 0);
	return O_K;
}

INT16 CData_Rindex(CData* _this, const char* sCname, INT32 nIc)
{
    INT32 i;
    if (nIc<0 || nIc>=CData_GetNComps(_this))
    {
      CData_AddComp(_this,sCname,T_LONG);
      nIc = CData_GetNComps(_this)-1;
    }
    CData_SetCname(_this,nIc,sCname);
    for (i=0; i<CData_GetNRecs(_this); i++)
      CData_Cstore(_this,CMPLX(i),i,nIc);
	return O_K;
}

INT16 CData_Scalop(CData* _this, data* idSrc, COMPLEX64 nConst, const char* sOpname)
{
    INT16 nOpcode = -1;
    CHECK_THIS_RV(NOT_EXEC);
    if ((nOpcode = dlp_scalop_code(sOpname))<0)
      return IERROR(_this,DATA_OPCODE,SCSTR(sOpname),"scalop",0);
    return CData_Scalop_Int(_this,idSrc,nConst,NULL,nOpcode,-1,-1);
	return O_K;
}

INT16 CData_ScalopD(CData* _this, data* idSrc, data* idConst, const char* sOpname)
{
    INT16 nOpcode = -1;
    CHECK_THIS_RV(NOT_EXEC);
    if ((nOpcode = dlp_scalop_code(sOpname))<0)
      return IERROR(_this,DATA_OPCODE,SCSTR(sOpname),"scalop_d",0);
    return CData_Scalop_Int(_this,idSrc,CMPLX(0),idConst,nOpcode,-1,-1);
	return O_K;
}

INT16 CData_Sortdown(CData* _this, data* x, INT32 j)
{
    CData_SortInt(_this,x,NULL,j,CDATA_SORT_DOWN);
	return O_K;
}

INT16 CData_Sortup(CData* _this, data* x, INT32 j)
{
           CData_SortInt(_this,x,NULL,j,CDATA_SORT_UP);
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CData::CData(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CData_Constructor(this,lpInstanceName,bCallVirtual);
}

CData::~CData()
{
	CData_Destructor(this);
}

INT16 CData::AutoRegisterWords()
{
	return CData_AutoRegisterWords(this);
}

INT16 CData::Init(BOOL bCallVirtual)
{
	return CData_Init(this,bCallVirtual);
}

INT16 CData::Reset(BOOL bResetMembers)
{
	return CData_Reset(this,bResetMembers);
}

INT16 CData::ClassProc()
{
	return CData_ClassProc(this);
}

INT16 CData::Serialize(CDN3Stream* lpDest)
{
	return CData_Serialize(this,lpDest);
}

INT16 CData::SerializeXml(CXmlStream* lpDest)
{
	return CData_SerializeXml(this,lpDest);
}

INT16 CData::Deserialize(CDN3Stream* lpSrc)
{
	return CData_Deserialize(this,lpSrc);
}

INT16 CData::DeserializeXml(CXmlStream* lpSrc)
{
	return CData_DeserializeXml(this,lpSrc);
}

INT16 CData::Copy(CDlpObject* __iSrc)
{
	return CData_Copy(this,__iSrc);
}

INT16 CData::InstallProc(void* lpItp)
{
	return CData_InstallProc(lpItp);
}

CData* CData::CreateInstance(const char* lpName)
{
	return CData_CreateInstance(lpName);
}

INT16 CData::GetClassInfo(SWord* lpClassWord)
{
	return CData_GetClassInfo(lpClassWord);
}

INT16 CData::GetInstanceInfo(SWord* lpClassWord)
{
	return CData_GetInstanceInfo(this,lpClassWord);
}

BOOL CData::IsKindOf(const char* lpClassName)
{
	return CData_IsKindOf(this,lpClassName);
}

INT16 CData::ResetAllOptions(BOOL bInit)
{
	return CData_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CData::OnInitializeRecord()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnInitializeRecord(this);
}

INT16 CData::OnAddComp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnAddComp(this);
}

INT16 CData::OnAddNcomps()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnAddNcomps(this);
}

INT16 CData::OnAggregate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnAggregate(this);
}

INT16 CData::OnAllocate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnAllocate(this);
}

INT16 CData::OnArray()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnArray(this);
}

INT16 CData::OnCat()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnCat(this);
}

INT16 CData::OnChecksum()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnChecksum(this);
}

INT16 CData::OnClear()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnClear(this);
}

INT16 CData::OnCompress()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnCompress(this);
}

INT16 CData::OnCopyCnames()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnCopyCnames(this);
}

INT16 CData::OnCopyDescr()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnCopyDescr(this);
}

INT16 CData::OnCopyLabels()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnCopyLabels(this);
}

INT16 CData::OnDelete()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnDelete(this);
}

INT16 CData::OnDequantize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnDequantize(this);
}

INT16 CData::OnDfetch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnDfetch(this);
}

INT16 CData::OnDmark()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnDmark(this);
}

INT16 CData::OnDstore()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnDstore(this);
}

INT16 CData::OnExpand()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnExpand(this);
}

INT16 CData::OnFetch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnFetch(this);
}

INT16 CData::OnFill()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnFill(this);
}

INT16 CData::OnFindComp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnFindComp(this);
}

INT16 CData::OnGenIndex()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnGenIndex(this);
}

INT16 CData::OnGetCname()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnGetCname(this);
}

INT16 CData::OnGetCnames()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnGetCnames(this);
}

INT16 CData::OnGetCompType()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnGetCompType(this);
}

INT16 CData::OnInitialize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnInitialize(this);
}

INT16 CData::OnInsertComp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnInsertComp(this);
}

INT16 CData::OnInsertNcomps()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnInsertNcomps(this);
}

INT16 CData::OnIsEmpty()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnIsEmpty(this);
}

INT16 CData::OnJoin()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnJoin(this);
}

INT16 CData::OnLookup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnLookup(this);
}

INT16 CData::OnLookup2()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnLookup2(this);
}

INT16 CData::OnMark()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnMark(this);
}

INT16 CData::OnPfetch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnPfetch(this);
}

INT16 CData::OnPrint()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnPrint(this);
}

INT16 CData::OnPstore()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnPstore(this);
}

INT16 CData::OnQuantize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnQuantize(this);
}

INT16 CData::OnReallocate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnReallocate(this);
}

INT16 CData::OnRepmat()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnRepmat(this);
}

INT16 CData::OnResample()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnResample(this);
}

INT16 CData::OnReshape()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnReshape(this);
}

INT16 CData::OnRindex()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnRindex(this);
}

INT16 CData::OnRotate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnRotate(this);
}

INT16 CData::OnScalop()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnScalop(this);
}

INT16 CData::OnScalopD()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnScalopD(this);
}

INT16 CData::OnScopy()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnScopy(this);
}

INT16 CData::OnSelect()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSelect(this);
}

INT16 CData::OnSetCname()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSetCname(this);
}

INT16 CData::OnSetCnames()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSetCnames(this);
}

INT16 CData::OnSfetch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSfetch(this);
}

INT16 CData::OnShift()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnShift(this);
}

INT16 CData::OnSortdown()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSortdown(this);
}

INT16 CData::OnSortup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSortup(this);
}

INT16 CData::OnSstore()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnSstore(this);
}

INT16 CData::OnStatus()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnStatus(this);
}

INT16 CData::OnStore()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnStore(this);
}

INT16 CData::OnStrop()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnStrop(this);
}

INT16 CData::OnTconvert()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnTconvert(this);
}

INT16 CData::OnUnmark()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnUnmark(this);
}

INT16 CData::OnXfetch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnXfetch(this);
}

INT16 CData::OnXstore()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnXstore(this);
}

INT16 CData::OnArrOp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CData_OnArrOp(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CData::Checksum(char* sAlgo, INT32 nIc)
{
	return CData_Checksum(this,sAlgo, nIc);
}

INT16 CData::Reallocate(INT32 nRecs)
{
	return CData_Reallocate(this,nRecs);
}

INT16 CData::Resample(data* iSrc, FLOAT64 nRate)
{
	return CData_Resample(this,iSrc, nRate);
}

INT16 CData::Rindex(const char* sCname, INT32 nIc)
{
	return CData_Rindex(this,sCname, nIc);
}

INT16 CData::Scalop(data* idSrc, COMPLEX64 nConst, const char* sOpname)
{
	return CData_Scalop(this,idSrc, nConst, sOpname);
}

INT16 CData::ScalopD(data* idSrc, data* idConst, const char* sOpname)
{
	return CData_ScalopD(this,idSrc, idConst, sOpname);
}

INT16 CData::Sortdown(data* x, INT32 j)
{
	return CData_Sortdown(this,x, j);
}

INT16 CData::Sortup(data* x, INT32 j)
{
	return CData_Sortup(this,x, j);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
BYTE* CData::XAddr(INT32 nRec, INT32 nComp)
{
	return CData_XAddr(this, nRec, nComp);
}

INT16 CData::Alloc(INT32 nRecs)
{
	return CData_Alloc(this, nRecs);
}

INT16 CData::AllocUninitialized(INT32 nRecs)
{
	return CData_AllocUninitialized(this, nRecs);
}

INT16 CData::AllocateUninitialized(INT32 nRecs)
{
	return CData_AllocateUninitialized(this, nRecs);
}

INT16 CData::Realloc(INT32 nRecs)
{
	return CData_Realloc(this, nRecs);
}

INT32 CData::AddRecs(INT32 nRecs, INT32 nRealloc)
{
	return CData_AddRecs(this, nRecs, nRealloc);
}

INT32 CData::InsertRecs(INT32 nInsertAt, INT32 nRecs, INT32 nRealloc)
{
	return CData_InsertRecs(this, nInsertAt, nRecs, nRealloc);
}

INT32 CData::GetNRecs()
{
	return CData_GetNRecs(this);
}

INT32 CData::GetNComps()
{
	return CData_GetNComps(this);
}

FLOAT64 CData::GetFsr()
{
	return CData_GetFsr(this);
}

INT32 CData::GetNNumericComps()
{
	return CData_GetNNumericComps(this);
}

INT32 CData::GetNComplexComps()
{
	return CData_GetNComplexComps(this);
}

INT32 CData::GetNBlocks()
{
	return CData_GetNBlocks(this);
}

INT32 CData::GetNRecsPerBlock()
{
	return CData_GetNRecsPerBlock(this);
}

INT32 CData::SetNBlocks(INT32 nBlocks)
{
	return CData_SetNBlocks(this, nBlocks);
}

INT32 CData::IncNRecs(INT32 nRecs)
{
	return CData_IncNRecs(this, nRecs);
}

INT32 CData::SetNRecs(INT32 nRecs)
{
	return CData_SetNRecs(this, nRecs);
}

INT32 CData::GetMaxRecs()
{
	return CData_GetMaxRecs(this);
}

INT32 CData::GetCompSize(INT32 nComp)
{
	return CData_GetCompSize(this, nComp);
}

INT32 CData::GetCompOffset(INT32 nComp)
{
	return CData_GetCompOffset(this, nComp);
}

INT32 CData::GetRecLen()
{
	return CData_GetRecLen(this);
}

INT32 CData::FindRec(INT32 nComp, char* sWhat)
{
	return CData_FindRec(this, nComp, sWhat);
}

INT32 CData::CcompFetch(COMPLEX64* dBuffer, INT32 nComp, INT32 nMaxRecs)
{
	return CData_CcompFetch(this, dBuffer, nComp, nMaxRecs);
}

INT32 CData::DcompFetch(FLOAT64* dBuffer, INT32 nComp, INT32 nMaxRecs)
{
	return CData_DcompFetch(this, dBuffer, nComp, nMaxRecs);
}

INT32 CData::CcompStore(COMPLEX64* dBuffer, INT32 nComp, INT32 nMaxRecs)
{
	return CData_CcompStore(this, dBuffer, nComp, nMaxRecs);
}

INT32 CData::DcompStore(FLOAT64* dBuffer, INT32 nComp, INT32 nMaxRecs)
{
	return CData_DcompStore(this, dBuffer, nComp, nMaxRecs);
}

INT32 CData::CrecFetch(COMPLEX64* lpBuffer, INT32 nRec, INT32 nMaxComps, INT32 nCompIgnore)
{
	return CData_CrecFetch(this, lpBuffer, nRec, nMaxComps, nCompIgnore);
}

INT32 CData::DrecFetch(FLOAT64* lpBuffer, INT32 nRec, INT32 nMaxComps, INT32 nCompIgnore)
{
	return CData_DrecFetch(this, lpBuffer, nRec, nMaxComps, nCompIgnore);
}

INT32 CData::CrecFetchInterpol(COMPLEX64* dBuffer, FLOAT64 nRec, INT32 nMaxComps, INT32 nCompIgnore, INT16 nMode)
{
	return CData_CrecFetchInterpol(this, dBuffer, nRec, nMaxComps, nCompIgnore, nMode);
}

INT32 CData::CrecStore(COMPLEX64* dBuffer, INT32 nRec, INT32 nMaxComps, INT32 nCompIgnore)
{
	return CData_CrecStore(this, dBuffer, nRec, nMaxComps, nCompIgnore);
}

INT32 CData::DrecStore(FLOAT64* dBuffer, INT32 nRec, INT32 nMaxComps, INT32 nCompIgnore)
{
	return CData_DrecStore(this, dBuffer, nRec, nMaxComps, nCompIgnore);
}

INT32 CData::CblockFetch(COMPLEX64* dBuffer, INT32 nBlock, INT32 nMaxComps, INT32 nMaxBrecs, INT32 nCompIgnore)
{
	return CData_CblockFetch(this, dBuffer, nBlock, nMaxComps, nMaxBrecs, nCompIgnore);
}

INT32 CData::DblockFetch(FLOAT64* dBuffer, INT32 nBlock, INT32 nMaxComps, INT32 nMaxBrecs, INT32 nCompIgnore)
{
	return CData_DblockFetch(this, dBuffer, nBlock, nMaxComps, nMaxBrecs, nCompIgnore);
}

INT32 CData::CblockStore(COMPLEX64* dBuffer, INT32 nBlock, INT32 nMaxComps, INT32 nMaxBrecs, INT32 nCompIgnore)
{
	return CData_CblockStore(this, dBuffer, nBlock, nMaxComps, nMaxBrecs, nCompIgnore);
}

INT32 CData::DblockStore(FLOAT64* dBuffer, INT32 nBlock, INT32 nMaxComps, INT32 nMaxBrecs, INT32 nCompIgnore)
{
	return CData_DblockStore(this, dBuffer, nBlock, nMaxComps, nMaxBrecs, nCompIgnore);
}

INT32 CData::DijFetch(FLOAT64* dBuffer, INT32 nRec, INT32 nComp, INT32 nMaxBlocks)
{
	return CData_DijFetch(this, dBuffer, nRec, nComp, nMaxBlocks);
}

INT32 CData::CijFetch(COMPLEX64* dBuffer, INT32 nRec, INT32 nComp, INT32 nMaxBlocks)
{
	return CData_CijFetch(this, dBuffer, nRec, nComp, nMaxBlocks);
}

COMPLEX64 CData::CfetchInterpol(FLOAT64 nRec, INT32 nComp, INT16 nMode)
{
	return CData_CfetchInterpol(this, nRec, nComp, nMode);
}

INT16 CData::SelectRecs(data* iSrc, INT32 from, INT32 count)
{
	return CData_SelectRecs(this, iSrc, from, count);
}

INT16 CData::SelectBlocks(data* iSrc, INT32 from, INT32 count)
{
	return CData_SelectBlocks(this, iSrc, from, count);
}

INT16 CData::SelectComps(data* iSrc, INT32 from, INT32 count)
{
	return CData_SelectComps(this, iSrc, from, count);
}

INT16 CData::DeleteRecs(INT32 from, INT32 count)
{
	return CData_DeleteRecs(this, from, count);
}

INT16 CData::DeleteBlocks(INT32 from, INT32 count)
{
	return CData_DeleteBlocks(this, from, count);
}

INT16 CData::DeleteComps(INT32 nFirst, INT32 nCount)
{
	return CData_DeleteComps(this, nFirst, nCount);
}

INT16 CData::CopyMarked(CData* idSrc, BOOL bPositive)
{
	return CData_CopyMarked(this, idSrc, bPositive);
}

INT16 CData::CheckCompType(INT16 nType)
{
	return CData_CheckCompType(this, nType);
}

FLOAT64 CData::GetDescr(INT16 nDescr)
{
	return CData_GetDescr(this, nDescr);
}

void CData::SetDescr(INT16 nDescr, FLOAT64 nValue)
{
	CData_SetDescr(this, nDescr, nValue);
}

INT32 CData::GenIndexList(data* iSrc, data* iTab, data* iLTab, INT32 nIdx)
{
	return CData_GenIndexList(this, iSrc, iTab, iLTab, nIdx);
}

INT16 CData::GenLabIndex(CData* iLabel, CData* iIndex, CData* iLTab)
{
	return CData_GenLabIndex(this, iLabel, iIndex, iLTab);
}

INT16 CData::CopyComps(CData* iSrc, INT32 is, INT32 it, INT32 n)
{
	return CData_CopyComps(this, iSrc, is, it, n);
}

INT16 CData::ResampleInt(CData* iSrc, FLOAT64 nRate, INT16 nMode)
{
	return CData_ResampleInt(this, iSrc, nRate, nMode);
}

INT16 CData::AddComp(const char* lpsName, INT16 nType)
{
	return CData_AddComp(this, lpsName, nType);
}

INT16 CData::AddNcomps(INT16 nCType, INT32 nCount)
{
	return CData_AddNcomps(this, nCType, nCount);
}

INT16 CData::InsertComp(const char* sCName, INT16 nCType, INT32 nInsertAt)
{
	return CData_InsertComp(this, sCName, nCType, nInsertAt);
}

INT16 CData::InsertNcomps(INT16 nCType, INT32 nInsertAt, INT32 nCount)
{
	return CData_InsertNcomps(this, nCType, nInsertAt, nCount);
}

INT16 CData::GetCompType(INT32 nComp)
{
	return CData_GetCompType(this, nComp);
}

INT16 CData::Scopy(data* lpSrc)
{
	return CData_Scopy(this, lpSrc);
}

INT16 CData::CopyCnames(data* iSrc, INT32 jx, INT32 jy, INT32 n)
{
	return CData_CopyCnames(this, iSrc, jx, jy, n);
}

INT16 CData::SetCnames(data* x, INT32 jx)
{
	return CData_SetCnames(this, x, jx);
}

INT16 CData::GetCnames(CData* idSrc)
{
	return CData_GetCnames(this, idSrc);
}

INT16 CData::SetCname(INT32 nIComp, const char* sCName)
{
	return CData_SetCname(this, nIComp, sCName);
}

const char* CData::GetCname(INT32 nIComp)
{
	return CData_GetCname(this, nIComp);
}

INT32 CData::FindComp(const char* lpName)
{
	return CData_FindComp(this, lpName);
}

INT16 CData::Allocate(INT32 n)
{
	return CData_Allocate(this, n);
}

INT16 CData::Array(INT16 nCType, INT32 nComps, INT32 nRecs)
{
	return CData_Array(this, nCType, nComps, nRecs);
}

BOOL CData::IsEmpty()
{
	return CData_IsEmpty(this);
}

COMPLEX64 CData::Cfetch(INT32 nIRec, INT32 nIComp)
{
	return CData_Cfetch(this, nIRec, nIComp);
}

FLOAT64 CData::Dfetch(INT32 nIRec, INT32 nIComp)
{
	return CData_Dfetch(this, nIRec, nIComp);
}

void* CData::Pfetch(INT32 nIRec, INT32 nIComp)
{
	return CData_Pfetch(this, nIRec, nIComp);
}

const char* CData::Sfetch(INT32 nIRec, INT32 nIComp)
{
	return CData_Sfetch(this, nIRec, nIComp);
}

INT16 CData::Cstore(COMPLEX64 dVal, INT32 nIRec, INT32 nIComp)
{
	return CData_Cstore(this, dVal, nIRec, nIComp);
}

INT16 CData::Dstore(FLOAT64 dVal, INT32 nIRec, INT32 nIComp)
{
	return CData_Dstore(this, dVal, nIRec, nIComp);
}

INT16 CData::Pstore(void* lpVal, INT32 nIRec, INT32 nIComp)
{
	return CData_Pstore(this, lpVal, nIRec, nIComp);
}

INT16 CData::Sstore(const char* sVal, INT32 nIRec, INT32 nIComp)
{
	return CData_Sstore(this, sVal, nIRec, nIComp);
}

INT16 CData::Clear()
{
	return CData_Clear(this);
}

INT16 CData::Fill(COMPLEX64 dStart, COMPLEX64 dDelta)
{
	return CData_Fill(this, dStart, dDelta);
}

INT16 CData::Lookup(data* dSel, INT32 nSelComp, data* dTab, INT32 nTabComp, INT32 nCount)
{
	return CData_Lookup(this, dSel, nSelComp, dTab, nTabComp, nCount);
}

INT16 CData::Lookup2(data* dSel1, INT32 nSel1Comp, data* dSel2, INT32 nSel2Comp, data* dTab)
{
	return CData_Lookup2(this, dSel1, nSel1Comp, dSel2, nSel2Comp, dTab);
}

INT16 CData::Aggregate(CData* iSrc, CData* iMask, COMPLEX64 dParam, const char* lpOpname)
{
	return CData_Aggregate(this, iSrc, iMask, dParam, lpOpname);
}

INT16 CData::GenIndex(data* iSrc, data* iTab, INT32 nSrcIdx, INT32 nTabIdx)
{
	return CData_GenIndex(this, iSrc, iTab, nSrcIdx, nTabIdx);
}

INT16 CData::Tconvert(data* idSrc, INT16 nCType)
{
	return CData_Tconvert(this, idSrc, nCType);
}

INT16 CData::CopyDescr(CData* iSrc)
{
	return CData_CopyDescr(this, iSrc);
}

INT16 CData::CopyMark(CData* iSrc)
{
	return CData_CopyMark(this, iSrc);
}

INT16 CData::CopyLabels(CData* iSrc)
{
	return CData_CopyLabels(this, iSrc);
}

INT16 CData::Join(data* x)
{
	return CData_Join(this, x);
}

INT16 CData::NJoin(data* x, INT32 jx, INT32 n)
{
	return CData_NJoin(this, x, jx, n);
}

INT16 CData::Cat(data* x)
{
	return CData_Cat(this, x);
}

INT16 CData::Select(CData* idSrc, INT32 nFirst, INT32 nCount)
{
	return CData_Select(this, idSrc, nFirst, nCount);
}

INT16 CData::Delete(CData* idSrc, INT32 nFirst, INT32 nCount)
{
	return CData_Delete(this, idSrc, nFirst, nCount);
}

INT16 CData::Mark(INT32 jx, INT32 n)
{
	return CData_Mark(this, jx, n);
}

INT16 CData::Dmark(CData* idMark)
{
	return CData_Dmark(this, idMark);
}

INT16 CData::Unmark()
{
	return CData_Unmark(this);
}

INT16 CData::Xfetch(INT32 nFirst, INT32 nCount)
{
	return CData_Xfetch(this, nFirst, nCount);
}

BOOL CData::Xstore(CData* idSrc, INT32 nFirst, INT32 nCount, INT32 nPos)
{
	return CData_Xstore(this, idSrc, nFirst, nCount, nPos);
}

BOOL CData::Reshape(CData* iSrc, INT32 nRec, INT32 nComp)
{
	return CData_Reshape(this, iSrc, nRec, nComp);
}

BOOL CData::Repmat(CData* iSrc, INT32 nRec, INT32 nComp)
{
	return CData_Repmat(this, iSrc, nRec, nComp);
}

INT16 CData::Shift(CData* iSrc, INT32 nCount)
{
	return CData_Shift(this, iSrc, nCount);
}

INT16 CData::Rotate(CData* iSrc, INT32 nCount)
{
	return CData_Rotate(this, iSrc, nCount);
}

INT16 CData::IsHomogen()
{
	return CData_IsHomogen(this);
}

INT16 CData::Print()
{
	return CData_Print(this);
}

INT16 CData::Status()
{
	return CData_Status(this);
}

INT16 CData::ArrOp()
{
	return CData_ArrOp(this);
}

INT16 CData::Quantize(CData* dIn)
{
	return CData_Quantize(this, dIn);
}

INT16 CData::Dequantize(CData* dIn)
{
	return CData_Dequantize(this, dIn);
}

INT16 CData::InitializeEx(INT32 nRec, INT32 nComp, INT32 nCount)
{
	return CData_InitializeEx(this, nRec, nComp, nCount);
}

INT32 CData::ReadInitializer(char* lpsInit, INT32 nLen, BOOL bForce)
{
	return CData_ReadInitializer(this, lpsInit, nLen, bForce);
}

INT16 CData::InitializeRecordEx(const char* lpsInit, INT32 nRec, INT32 nComp)
{
	return CData_InitializeRecordEx(this, lpsInit, nRec, nComp);
}

INT16 CData::Initialize()
{
	return CData_Initialize(this);
}

INT16 CData::InitializeRecord(INT32 nRec)
{
	return CData_InitializeRecord(this, nRec);
}

INT16 CData::VerifyMarkMap()
{
	return CData_VerifyMarkMap(this);
}

INT16 CData::MarkElem(INT32 nElem)
{
	return CData_MarkElem(this, nElem);
}

BOOL CData::IsMarked(INT32 nElem)
{
	return CData_IsMarked(this, nElem);
}

BOOL CData::RecIsMarked(INT32 nRec)
{
	return CData_RecIsMarked(this, nRec);
}

BOOL CData::CompIsMarked(INT32 nComp)
{
	return CData_CompIsMarked(this, nComp);
}

BOOL CData::BlockIsMarked(INT32 nBlock)
{
	return CData_BlockIsMarked(this, nBlock);
}

BOOL CData::CellIsMarked(INT32 nCell)
{
	return CData_CellIsMarked(this, nCell);
}

INT32 CData::MicGetIc(INT16 nArg, INT16 nPos)
{
	return CData_MicGetIc(this, nArg, nPos);
}

INT16 CData::PrintText()
{
	return CData_PrintText(this);
}

INT16 CData::PrintRec(INT32 nRec, INT32 nIcFirst, INT32 nComps, INT16 nIndent)
{
	return CData_PrintRec(this, nRec, nIcFirst, nComps, nIndent);
}

INT16 CData::PrintList()
{
	return CData_PrintList(this);
}

INT16 CData::PrintVectors_GetColWidth(INT32 nR0, INT32 nC0, INT32* lpnWI, INT32* lpnW0, INT32* lpnW)
{
	return CData_PrintVectors_GetColWidth(this, nR0, nC0, lpnWI, lpnW0, lpnW);
}

INT32 CData::PrintVectors_Block(INT32 nBlock)
{
	return CData_PrintVectors_Block(this, nBlock);
}

INT16 CData::PrintVectors()
{
	return CData_PrintVectors(this);
}

INT16 CData::Scalop_C(COMPLEX64 nConst, INT16 nOpcode, INT32 nComp)
{
	return CData_Scalop_C(this, nConst, nOpcode, nComp);
}

INT16 CData::Scalop_Int(CData* idSrc, COMPLEX64 nConst, CData* idConst, INT16 nOpcode, INT16 nType, INT32 nComp)
{
	return CData_Scalop_Int(this, idSrc, nConst, idConst, nOpcode, nType, nComp);
}

INT16 CData::Aggregate_Int(CData* iSrc, CData* iMask, COMPLEX64 dParam, INT16 nOpcode)
{
	return CData_Aggregate_Int(this, iSrc, iMask, dParam, nOpcode);
}

INT16 CData::Strop(CData* idSrc, const char* sParam, const char* sOpname)
{
	return CData_Strop(this, idSrc, sParam, sOpname);
}

INT16 CData::Compress(CData* iSrc, INT32 nComp)
{
	return CData_Compress(this, iSrc, nComp);
}

INT16 CData::Expand(CData* idSrc, INT32 nIcE, INT32 nIcS, INT32 nIcL)
{
	return CData_Expand(this, idSrc, nIcE, nIcS, nIcL);
}

INT16 CData::ExpandComp(CData* idSrc, INT32 nIcE, INT32 nIcS, INT32 nIcL)
{
	return CData_ExpandComp(this, idSrc, nIcE, nIcS, nIcL);
}

INT16 CData::SortInt(CData* iSrc, CData* iIdx, INT32 nComp, INT16 nMode)
{
	return CData_SortInt(this, iSrc, iIdx, nComp, nMode);
}

INT32 CData::ChecksumInt(char* sAlgo, INT32 nIc)
{
	return CData_ChecksumInt(this, sAlgo, nIc);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */

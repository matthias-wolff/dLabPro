// dLabPro class CHistogram (histogram)
// - Vector histogram
//
// AUTHOR : C.-M. Westendorf
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify histogram.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_histogram.h"

// Class CHistogram

CHistogram::CHistogram(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CHistogram::CHistogram; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"histogram");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"histogram");
	dlp_strcpy(m_version.no,"2.20 SLC 1.3.98");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CHistogram::~CHistogram()
{
  //{{CGEN_DONECODE
  if (m_minm==m_minmax) m_minmax=NULL;
  if (m_minm) { data_destroy(m_minm); m_minm=NULL; }
  DONE;
  //}}CGEN_DONECODE
}

INT16 CHistogram::AutoRegisterWords()
{
	DEBUGMSG(-1,"CHistogram::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS

	// Register methods
	REGISTER_METHOD("-chiqu_stat","",LPMF(CHistogram,OnChiquStat),"Chi-quadrat-statistic of two histogram sets",0,"<histogram h> <data chi> <histogram this>","")
	REGISTER_METHOD("-chiqu_stat_a","",LPMF(CHistogram,OnChiquStatA),"Chi-quadrat-statistic inside one histogram set",0,"<data chi> <int ic> <histogram this>","")
	REGISTER_METHOD("-clear","",LPMF(CHistogram,Clear),"Clear histogram(s)",0,"<histogram this>","")
	REGISTER_METHOD("-copy_hbl","",LPMF(CHistogram,OnCopyHbl),"Copy histogram block i to block j",0,"<int i> <int j> <histogram this>","")
	REGISTER_METHOD("-mcopy_hbl","",LPMF(CHistogram,OnMcopyHbl),"Copy histogram block i to all blocks",0,"<int i> <histogram this>","")
	REGISTER_METHOD("-meanvar","",LPMF(CHistogram,OnMeanvar),"Mean/variance from histogram",0,"<data mean> <data var> <histogram this>","")
	REGISTER_METHOD("-poole","",LPMF(CHistogram,OnPoole),"Compute pooled (overall) histogram hp, unweighted",0,"<histogram hp> <histogram this>","")
	REGISTER_METHOD("-print_index","",LPMF(CHistogram,PrintIndex),"Print index list",0,"<histogram this>","")
	REGISTER_METHOD("-print_labtab","",LPMF(CHistogram,PrintLabtab),"Print label table",0,"<histogram this>","")
	REGISTER_METHOD("-print_minmax","",LPMF(CHistogram,PrintMinmax),"Print current minmax-data",0,"<histogram this>","")
	REGISTER_METHOD("-print_st","",LPMF(CHistogram,OnPrintSt),"Print statistic of histogram block i",0,"<int i> <histogram this>","")
	REGISTER_METHOD("-quantil","",LPMF(CHistogram,OnQuantil),"Wuantil interval from histogram",0,"<data qlo> <data qhi> <data pql> <double p> <histogram this>","")
	REGISTER_METHOD("-reorg","",LPMF(CHistogram,OnReorg),"Reorganize histograms",0,"<data ex> <histogram this>","")
	REGISTER_METHOD("-reset","",LPMF(CHistogram,VhReset),"Reset histogram(s)",0,"<histogram this>","")
	REGISTER_METHOD("-select","",LPMF(CHistogram,OnSelect),"Select histogram block i",0,"<data h> <int i> <histogram this>","")
	REGISTER_METHOD("-show","",LPMF(CHistogram,OnShow),"Show histogram block i",0,"<int i> <data idOut> <histogram this>","")
	REGISTER_METHOD("-show_c","",LPMF(CHistogram,OnShowC),"Show component ic of histogram block i",0,"<int i> <int ic> <data idOut> <histogram this>","")
	REGISTER_METHOD("-status","",LPMF(CHistogram,Status),"Print status",0,"<histogram this>","")
	REGISTER_METHOD("-update","",LPMF(CHistogram,OnUpdate),"Histogram update, index independent",0,"<data x> <histogram this>","")
	REGISTER_METHOD("-update_i","",LPMF(CHistogram,OnUpdateI),"Histogram update, index dependent",0,"<data x> <data itab> <histogram this>","")
	REGISTER_METHOD("-update_iw","",LPMF(CHistogram,OnUpdateIw),"Weighted histogram update, index dependent",0,"<data x> <data itab> <data w> <histogram this>","")
	REGISTER_METHOD("-update_w","",LPMF(CHistogram,OnUpdateW),"Soft histogram update",0,"<data x> <data w> <histogram this>","")

	// Register options
	REGISTER_OPTION("/window","",LPMV(m_bWindow),LPMF(CHistogram,OnWindowSet),"Windowed update",0)

	// Register fields
	REGISTER_FIELD("bins","",LPMV(m_bins),LPMF(CHistogram,OnBinsChanged),"histogram quant. steps",0,2004,1,"int",(INT32)32)
	REGISTER_FIELD("calls","",LPMV(m_calls),NULL,"update calls",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("cname","",LPMV(m_cname),NULL,"name of index comp. in data",0,5,5,"char[5]","")
	REGISTER_FIELD("count","",LPMV(m_count),NULL,"local sample size",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("hdim","",LPMV(m_hdim),NULL,"numeric components",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("hist","",LPMV(m_hist),LPMF(CHistogram,OnHistChanged),"histogram data",0,6002,1,"data",NULL)
	REGISTER_FIELD("hmode","",LPMV(m_hmode),NULL,"histogram mode",FF_NOSET,2002,1,"short",(INT16)1)
	REGISTER_FIELD("icomp","",LPMV(m_icomp),NULL,"index comp. in data",0,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("indexlist","",LPMV(m_indexlist),NULL,"index list",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("labtab","",LPMV(m_labtab),NULL,"label table",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("max","",LPMV(m_max),LPMF(CHistogram,OnMaxChanged),"maximum in mode 1",0,3008,1,"double",(FLOAT64)1.)
	REGISTER_FIELD("min","",LPMV(m_min),LPMF(CHistogram,OnMinChanged),"minimum in hmode 1",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("minm","",LPMV(m_minm),NULL,"predefined min-max data instance",FF_HIDDEN,6002,1,"data",NULL)
	REGISTER_FIELD("minmax","",LPMV(m_minmax),LPMF(CHistogram,OnMinmaxChanged),"current min-max data",0,6002,1,"data",NULL)
	REGISTER_FIELD("nhist","",LPMV(m_nhist),LPMF(CHistogram,OnNhistChanged),"number of histograms",0,2004,1,"int",(INT32)1)
	REGISTER_FIELD("pl","",LPMV(m_pl),NULL,"verbose level",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("ssize","",LPMV(m_ssize),NULL,"overall sample size",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("wflag","",LPMV(m_wflag),NULL,"flag for windowed update",FF_HIDDEN,2002,1,"short",(INT16)0)

	// Register errors
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,HIS_ZERO,"A data pointer is NULL.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,HIS_INCONS,"Used data are inconsistent.")
	REGISTER_ERROR("~e3_0_0__1",EL_ERROR,HIS_EMPTY,"Data are empty.")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,HIS_NOINP,"Input data are empty.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,HIS_TYPE,"Called with data incorrect in type")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,HIS_TAB,"Called with incorrect label table data.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,HIS_NODAT,"There is no numeric component in input data.")
	REGISTER_ERROR("~e8_0_0__1",EL_ERROR,HIS_NOLAB,"There is no label component in input data.")
	REGISTER_ERROR("~e9_0_0__1",EL_ERROR,HIS_HISTO,"Incorrect histogram data.")
	REGISTER_ERROR("~e0_1_0__1",EL_ERROR,HIS_INDEX,"Incorrect index data.")
	REGISTER_ERROR("~e1_1_0__1",EL_ERROR,HIS_NOIC,"Missing index component in data.")
	REGISTER_ERROR("~e2_1_0__1",EL_ERROR,HIS_NOEXEC,"Not executed by any reason.")
	REGISTER_ERROR("~e3_1_0__1",EL_ERROR,HIS_NOSTEPS,"To less bins (%d).")
	REGISTER_ERROR("~e4_1_0__1",EL_ERROR,HIS_MINMAXERR,"Parameter min=%g > max=%g ! Standard values used.")
	REGISTER_ERROR("~e5_1_0__1",EL_ERROR,HIS_BINERR,"Reset histogram before changing bins.")
	REGISTER_ERROR("~e6_1_0__1",EL_ERROR,HIS_SHORTLIST,"Index list is shorter than data ... only %d records")
	REGISTER_ERROR("~e7_1_0__1",EL_ERROR,HIS_SHORTWEIGHT,"Weighting sequence is shorter than data ... only %d records")
	REGISTER_ERROR("~e8_1_0__1",EL_ERROR,HIS_POOLE,"Sorry, pooling only for hmode = 1 or 2 possible ...")
	REGISTER_ERROR("~e9_1_0__1",EL_ERROR,HIS_NODISP,"No display instance available.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CHistogram::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CHistogram::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CHistogram::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CHistogram::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  RESET;
  IFIELD_RESET(CData,"hist");
  IFIELD_RESET(CData,"labtab");
  IFIELD_RESET(CData,"indexlist");
  SetDefMinmax();
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CHistogram::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CHistogram::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CHistogram::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CHistogram::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CHistogram::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CHistogram::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CHistogram::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CHistogram* CHistogram::CreateInstance(const char* lpName)
{
	CHistogram* lpNewInstance;
	ICREATEEX(CHistogram,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CHistogram::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CHistogram::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CHistogram::InstallProc;
	lpClassWord->ex.fct.lpProject   = "histogram";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Vector histogram";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CHistogram";
	lpClassWord->ex.fct.lpAuthor    = "C.-M. Westendorf";

	dlp_strcpy(lpClassWord->lpName             ,"histogram");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"2.20 SLC 1.3.98");

	return O_K;
}

INT16 CHistogram::GetInstanceInfo(SWord* lpClassWord)
{
	return CHistogram::GetClassInfo(lpClassWord);
}

BOOL CHistogram::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"histogram",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CHistogram::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CHistogram::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bWindow = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CHistogram::OnChiquStat()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* chi = MIC_GET_I_EX(chi,data,1,1);
	histogram* h = MIC_GET_I_EX(h,histogram,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ChiquStat(h, chi);
	return __nErr;
}

INT16 CHistogram::OnChiquStatA()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 ic = (INT32)MIC_GET_N(1,0);
	data* chi = MIC_GET_I_EX(chi,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ChiquStatA(chi, ic);
	return __nErr;
}

INT16 CHistogram::OnCopyHbl()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 j = (INT32)MIC_GET_N(1,0);
	INT32 i = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CopyHbl(i, j);
	return __nErr;
}

INT16 CHistogram::OnMcopyHbl()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 i = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = McopyHbl(i);
	return __nErr;
}

INT16 CHistogram::OnMeanvar()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* var = MIC_GET_I_EX(var,data,1,1);
	data* mean = MIC_GET_I_EX(mean,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Meanvar(mean, var);
	return __nErr;
}

INT16 CHistogram::OnPoole()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	histogram* hp = MIC_GET_I_EX(hp,histogram,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Poole(hp);
	return __nErr;
}

INT16 CHistogram::OnPrintSt()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 i = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = PrintSt(i);
	return __nErr;
}

INT16 CHistogram::OnQuantil()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	FLOAT64 p = MIC_GET_N(1,0);
	data* pql = MIC_GET_I_EX(pql,data,2,1);
	data* qhi = MIC_GET_I_EX(qhi,data,3,2);
	data* qlo = MIC_GET_I_EX(qlo,data,4,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Quantil(qlo, qhi, pql, p);
	return __nErr;
}

INT16 CHistogram::OnReorg()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* ex = MIC_GET_I_EX(ex,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Reorg(ex);
	return __nErr;
}

INT16 CHistogram::OnSelect()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 i = (INT32)MIC_GET_N(1,0);
	data* h = MIC_GET_I_EX(h,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Select(h, i);
	return __nErr;
}

INT16 CHistogram::OnShow()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idOut = MIC_GET_I_EX(idOut,data,1,1);
	INT32 i = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Show(i, idOut);
	return __nErr;
}

INT16 CHistogram::OnShowC()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idOut = MIC_GET_I_EX(idOut,data,1,1);
	INT32 ic = (INT32)MIC_GET_N(2,0);
	INT32 i = (INT32)MIC_GET_N(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ShowC(i, ic, idOut);
	return __nErr;
}

INT16 CHistogram::OnUpdate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* x = MIC_GET_I_EX(x,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Update(x);
	return __nErr;
}

INT16 CHistogram::OnUpdateI()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* itab = MIC_GET_I_EX(itab,data,1,1);
	data* x = MIC_GET_I_EX(x,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = UpdateI(x, itab);
	return __nErr;
}

INT16 CHistogram::OnUpdateIw()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* w = MIC_GET_I_EX(w,data,1,1);
	data* itab = MIC_GET_I_EX(itab,data,2,2);
	data* x = MIC_GET_I_EX(x,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = UpdateIw(x, itab, w);
	return __nErr;
}

INT16 CHistogram::OnUpdateW()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* w = MIC_GET_I_EX(w,data,1,1);
	data* x = MIC_GET_I_EX(x,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = UpdateW(x, w);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
INT16 CHistogram::ChiquStat(histogram* h, data* chi)
{
    Chiqu (this, h, chi);
	return O_K;
}

INT16 CHistogram::ChiquStatA(data* chi, INT32 ic)
{
    ChiquComp (chi, ic);
	return O_K;
}

INT16 CHistogram::Clear()
{
      m_calls  =  0;
      m_count  =  0;
      m_ssize  =  0;
      data_clear (m_hist);
	return O_K;
}

INT16 CHistogram::CopyHbl(INT32 i, INT32 j)
{
        CopyBlock (i, j);
	return O_K;
}

INT16 CHistogram::McopyHbl(INT32 i)
{
          CopyBlock (i, -1);
	return O_K;
}

INT16 CHistogram::Meanvar(data* mean, data* var)
{
        MeanVar ( mean, var );
	return O_K;
}

INT16 CHistogram::PrintIndex()
{
    data_print (m_indexlist);
	return O_K;
}

INT16 CHistogram::PrintLabtab()
{
    data_print (m_labtab);
	return O_K;
}

INT16 CHistogram::PrintMinmax()
{
    data_print (m_minmax);
	return O_K;
}

INT16 CHistogram::PrintSt(INT32 i)
{
    PrintPar (i);
	return O_K;
}

INT16 CHistogram::Quantil(data* qlo, data* qhi, data* pql, FLOAT64 p)
{
         Pquantil (qlo, qhi, pql, p );
	return O_K;
}

INT16 CHistogram::Reorg(data* ex)
{
    ReorgEx(ex, 0);
	return O_K;
}

INT16 CHistogram::VhReset()
{
    m_calls  =  0;
    m_count  =  0;
    m_ssize  =  0;
    m_hdim   =  0;
          m_nhist  =  0;
          data_reset (m_hist);
	return O_K;
}

INT16 CHistogram::Select(data* h, INT32 i)
{
        SelectBlock (h, i, -1);
	return O_K;
}

INT16 CHistogram::Show(INT32 i, data* idOut)
{
    ShowEx(i,-1,"",idOut);
	return O_K;
}

INT16 CHistogram::ShowC(INT32 i, INT32 ic, data* idOut)
{
    ShowEx(i,ic,"",idOut);
	return O_K;
}

INT16 CHistogram::Status()
{
    PrintStatus ();
	return O_K;
}

INT16 CHistogram::Update(data* x)
{
    FindIndexcomp (x);
    UpdateHist    (x,NULL);
    UpdateHdesc   ();
	return O_K;
}

INT16 CHistogram::UpdateI(data* x, data* itab)
{
    FindIndexcomp(x);
    GenIndexlist(x,itab);
    UpdateHist(x,NULL);
    UpdateHdesc();
	return O_K;
}

INT16 CHistogram::UpdateIw(data* x, data* itab, data* w)
{
    FindIndexcomp (x);
    GenIndexlist  (x,itab);
    UpdateHist    (x, w);
    UpdateHdesc ();
	return O_K;
}

INT16 CHistogram::UpdateW(data* x, data* w)
{
    FindIndexcomp   (x);
    UpdateHist      (x, w);
    UpdateHdesc     ();
	return O_K;
}

//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
INT16 CHistogram::OnWindowSet()
{
    m_wflag = 1;

	return O_K;
}

//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
INT16 CHistogram::OnBinsChanged()
{
    if (data_empty(m_hist) != TRUE)
    {  if (m_bins != HIS_STEPS)
        IERROR(this,HIS_BINERR,0,0,0);
      m_bins=HIS_STEPS;
    }

	return O_K;
}

INT16 CHistogram::OnHistChanged()
{
    m_calls  = 0;
    m_count  = 0;
    m_ssize  = 0;
    m_hmode  = 1;
    if (data_empty(m_hist) != TRUE)
    {
      m_nhist   =data_nblock(m_hist);
      m_hdim =data_dim(m_hist);
    }

	return O_K;
}

INT16 CHistogram::OnMaxChanged()
{
    if (m_minmax && m_minmax!=m_minm) data_destroy(m_minmax);
    m_minmax=m_minm;
    SetDefMinmax();

	return O_K;
}

INT16 CHistogram::OnMinChanged()
{
    if (m_minmax && m_minmax!=m_minm) data_destroy(m_minmax);
    m_minmax=m_minm;
    SetDefMinmax();

	return O_K;
}

INT16 CHistogram::OnMinmaxChanged()
{
    if ((m_hmode=CheckMinmax()) < 1)
    {
      if (m_minmax && m_minmax!=m_minm) data_destroy(m_minmax);
      m_minmax = m_minm;
      SetDefMinmax();
      return(O_K);
    }
    if (data_empty(m_hist) != TRUE)
    {
      if (CheckConsist() != O_K)
       {
        if (m_minmax && m_minmax!=m_minm) data_destroy(m_minmax);
        m_minmax = m_minm;
        SetDefMinmax();
        return (O_K);
      }
    }
    //printf (       "\n o.k. - new minmax data assigned; hmode=%d", m_hmode);

	return O_K;
}

INT16 CHistogram::OnNhistChanged()
{
    ReorgEx(NULL, m_nhist);

	return O_K;
}

//}}CGEN_FCCF


// EOF

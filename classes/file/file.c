/* dLabPro class CDlpFile (file)
 * - File list processor and import/export filters
 *
 * AUTHOR : M. Wolff, M. Eichner and M. Cuevas
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify file.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_file.h"

/* Class CDlpFile */

void CDlpFile_Constructor(CDlpFile* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CDlpFile_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CDlpFile),
		__FILE__,__LINE__,"file",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CDlpFile_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CDlpFile_Reset;
	_this->m_lpBaseInstance->Init              = CDlpFile_Init;
	_this->m_lpBaseInstance->Serialize         = CDlpFile_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CDlpFile_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CDlpFile_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CDlpFile_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CDlpFile_Copy;
	_this->m_lpBaseInstance->ClassProc         = CDlpFile_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CDlpFile_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CDlpFile_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CDlpFile_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CDlpFile_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"file");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"file");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.1.2");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOINSTANCE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CDlpFile_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CDlpFile);
	{
	/*{{CGEN_DONECODE */

  /* free list of filetypes */
  if(_this->m_lpFtypes)
  {
  list_process(_this->m_lpFtypes,NULL,CDlpFile_FreeFTypeList);
  list_destroy_nodes(_this->m_lpFtypes);
  list_destroy(_this->m_lpFtypes);
  _this->m_lpFtypes = NULL;
  }

  DONE;

	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CDlpFile_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	DEBUGMSG(-1,"CDlpFile_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-exists","",LPMF(CDlpFile,OnExists),"Checks if directory exists",0,"<string sFilename> <file this>","")
	REGISTER_METHOD("-export","",LPMF(CDlpFile,OnExport),"Exports an instance to a non-native file format",0,"<cstring sFilename> <cstring sFilter> <instance iInst> <file this>","")
	REGISTER_METHOD("-get_root_class","",LPMF(CDlpFile,OnGetRootClass),"Reads root class from dn3 or xml file",0,"<string sFilename> <file this>","")
	REGISTER_METHOD("-getlen","",LPMF(CDlpFile,OnGetlen),"Return number of items in file list.",0,"<file this>","")
	REGISTER_METHOD("-import","",LPMF(CDlpFile,OnImport),"Imports an instance from a non-native file format",0,"<cstring sFilename> <cstring sFilter> <instance iInst> <file this>","")
	REGISTER_METHOD("-list","",LPMF(CDlpFile,OnList),"Lists available import and export filters.",0,"<file this>","")
	REGISTER_METHOD("-next","",LPMF(CDlpFile,OnNext),"Push next file in list to string stack.",0,"<file this>","")
	REGISTER_METHOD("-partition","",LPMF(CDlpFile,OnPartition),"Partitiones a file list",0,"<file iSrc> <double nPartSize> <int nPartNum> <file this>","")

	/* Register options */
	REGISTER_OPTION("/append","",LPMV(m_bAppend),NULL,"Do append to (existing) file while exporting",0)
	REGISTER_OPTION("/big","",LPMV(m_bBig),NULL,"Import raw data in big endian format.",0)
	REGISTER_OPTION("/compress","",LPMV(m_bCompress),NULL,"Compressed import/export",0)
	REGISTER_OPTION("/dir","",LPMV(m_bDir),NULL,"Directory mode",0)
	REGISTER_OPTION("/execute","",LPMV(m_bExecute),NULL,"Do execute command instead of opening file",0)
	REGISTER_OPTION("/little","",LPMV(m_bLittle),NULL,"Import raw data in little endian format.",0)
	REGISTER_OPTION("/pst_comma","",LPMV(m_bPstComma),NULL,"Plot German style numbers.",0)
	REGISTER_OPTION("/pst_contour","",LPMV(m_bPstContour),NULL,"Plots contour for PSTricks export.",0)
	REGISTER_OPTION("/pst_halfspectrum","",LPMV(m_bPstHalfspectrum),NULL,"Plot left-side of spectrum for PSTricks export.",0)
	REGISTER_OPTION("/pst_legend","",LPMV(m_bPstLegend),NULL,"Plot a legend for PSTricks export.",0)
	REGISTER_OPTION("/pst_triglabels","",LPMV(m_bPstTriglabels),NULL,"Plot trigonometric labels for PSTricks export.",0)
	REGISTER_OPTION("/pst_x_y_plot","",LPMV(m_bPstXYPlot),NULL,"XY-Plot for PSTricks export.",0)
	REGISTER_OPTION("/reverse","",LPMV(m_bReverse),NULL,"Reverse byte order in raw import",0)
	REGISTER_OPTION("/strings","",LPMV(m_bStrings),NULL,"Determine only string columns while ascii-import",0)
	REGISTER_OPTION("/transpose","",LPMV(m_bTranspose),NULL,"Interchange rows and columns for ascii-export.",0)
	REGISTER_OPTION("/zip","",LPMV(m_bZip),NULL,"Zip after export",0)

	/* Register fields */
	REGISTER_FIELD("comment","",LPMV(m_lpsComment),NULL,"Comment marker used for import and export of ASCII files.",0,10,10,"char[10]","#")
	REGISTER_FIELD("ext","",LPMV(m_lpsExt),LPMF(CDlpFile,OnExtChanged),"File extension to succeed file list items.",0,32,32,"char[32]","")
	REGISTER_FIELD("flist","",LPMV(m_lpsFlist),LPMF(CDlpFile,OnFlistChanged),"Filename of file list.",0,255,255,"char[255]","")
	REGISTER_FIELD("flist_data","",LPMV(m_idFlistData),LPMF(CDlpFile,OnFlistDataChanged),"File list data field.",0,6002,1,"data",NULL)
	REGISTER_FIELD("ftypes","",LPMV(m_lpFtypes),NULL,"List of known file types for export and import of non-native files.",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"list_t*",NULL)
	REGISTER_FIELD("len","",LPMV(m_nLen),NULL,"Length of file list",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("line_flt","",LPMV(m_lpsLineFlt),NULL,"Line filter used for import and export of ASCII files.",0,32,32,"char[32]","")
	REGISTER_FIELD("nfile","",LPMV(m_nNfile),NULL,"Current zero-based file index in file list.",FF_NOSET,2004,1,"int",(INT32)-1)
	REGISTER_FIELD("path","",LPMV(m_lpsPath),LPMF(CDlpFile,OnPathChanged),"Path to preceed file list items.",0,255,255,"char[255]","")
	REGISTER_FIELD("raw_head","",LPMV(m_nRawHead),NULL,"Number of bytes to skip importing raw files.",0,2008,1,"long",(INT64)0)
	REGISTER_FIELD("recfile","",LPMV(m_idRecfile),NULL,"Current record in file list (including extra components)",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("sep","",LPMV(m_lpsSep),NULL,"List of separators used for import/export of ASCII files.",0,10,10,"char[10]","\t ")
	REGISTER_FIELD("sfile","current_file",LPMV(m_lpsSfile),NULL,"Current file name in file list without path and extension.",FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("sfile_fq","current_full_name",LPMV(m_lpsSfileFq),NULL,"Current file name in file list including path and extension.",FF_NOSET,255,255,"char[255]","")

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,FIL_NEEDFL,"Need a file list (parameter <flist>).")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,FIL_FILENAME,"No filename specified.")
	REGISTER_ERROR("~e3_0_0__1",EL_ERROR,FIL_NOIMEX,"No %s method for '%s' file into '%s' instance.")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,FIL_IMPORT,"Failed to import file '%s' using filter '%s'.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,FIL_NOEXPORT,"No export method for '%s' file from '%s' instance.")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,FIL_EXPORT,"Failed to export file '%s' using filter '%s'.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,FIL_PROCESS,"Error while %s file %s.")
	REGISTER_ERROR("~e8_0_0__1",EL_ERROR,FIL_FORMAT,"Format error in file %s of type %s (%s).")
	REGISTER_ERROR("~e9_0_0__1",EL_WARNING,FIL_FORMATW,"Format error in file %s of type %s (%s).")
	REGISTER_ERROR("~e0_1_0__1",EL_ERROR,FIL_FORMATCOMPS,"All numeric components of %s must be of same type.")
	REGISTER_ERROR("~e1_1_0__1",EL_ERROR,FIL_FSR,"No valid continuation rate specified. Please set field 'fsr' of instance '%s' accordingly.")
	REGISTER_ERROR("~e2_1_0__1",EL_WARNING,FIL_PHD_SMM,"Counted samples incorrect (%ld != %ld).")
	REGISTER_ERROR("~e3_1_0__1",EL_WARNING,FIL_PHD_EMPTY_HEADER,"Invalid header detected. Assuming 16kHz data.")
	REGISTER_ERROR("~e4_1_0__1",EL_ERROR,FIL_NOTIMPL,"%s is not implemented.")
	REGISTER_ERROR("~e5_1_0__1",EL_ERROR,FIL_BADTYPE,"Component %d of %s must be of %s type.")
	REGISTER_ERROR("~e6_1_0__1",EL_ERROR,FIL_BADCOMPS,"Instance %s must must have %d components.")
	REGISTER_ERROR("~e7_1_0__1",EL_ERROR,IC_TIS_NOT_SET,"Field ic_tis in structure %s must be bigger than 1.")
	REGISTER_ERROR("~e8_1_0__1",EL_ERROR,FIL_DLP,"Need dLabPro interpreter.")
	REGISTER_ERROR("~e9_1_0__1",EL_WARNING,FIL_REMOVE,"Cannot remove %sfile '%s'.")
	REGISTER_ERROR("~e0_2_0__1",EL_ERROR,FIL_EXEC,"Cannot execute shell command '%s'. Check path.")
	REGISTER_ERROR("~e1_2_0__1",EL_ERROR,FIL_NOTFOUND,"Cannot find %s.")
	REGISTER_ERROR("~e2_2_0__1",EL_ERROR,FIL_WAV_MISS,"File %s doesn't contain %s!")
	REGISTER_ERROR("~e3_2_0__1",EL_ERROR,FIL_INVALARG,"Invalid argument (%s).")
	REGISTER_ERROR("~e4_2_0__1",EL_WARNING,FIL_OPTION,"Option %s will be ignored due to %s.")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CDlpFile_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	DEBUGMSG(-1,"CDlpFile_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */

  INIT;

  /* create list of filters for import / export */
  _this->m_lpFtypes = list_create(LISTCOUNT_T_MAX);

  /* add filters to list */
  ADD_FILETYPE("ascii"    ,"data"     ,IMPORT_FILE,   "White space delimited ASCII"      ,CDlpFile_ImportAsciiToData          );
  ADD_FILETYPE("ascii"    ,"data"     ,EXPORT_FILE,   "White space delimited ASCII"      ,CDlpFile_ExportAsciiFromData        );
  ADD_FILETYPE("csv"      ,"data"     ,IMPORT_FILE,   "Comma separated values file"      ,CDlpFile_ImportAsciiToData          );
  ADD_FILETYPE("csv_de"   ,"data"     ,IMPORT_FILE,   "Semicolon sep. values file"       ,CDlpFile_ImportAsciiToData          );
  ADD_FILETYPE("csv"      ,"data"     ,EXPORT_FILE,   "Comma separated values file"      ,CDlpFile_ExportAsciiFromData        );
  ADD_FILETYPE("csv_de"   ,"data"     ,EXPORT_FILE,   "Semicolon sep. values file"       ,CDlpFile_ExportAsciiFromData        );
  ADD_FILETYPE("wav"      ,"data"     ,IMPORT_FILE,  "Microsoft WAV audio"              ,CDlpFile_LibsndfileImport           );
  ADD_FILETYPE("wav"      ,"data"     ,EXPORT_FILE,  "Microsoft WAV audio"              ,CDlpFile_LibsndfileExport           );
  ADD_FILETYPE("aiff"     ,"data"     ,IMPORT_FILE,   "Audio Interchange File Format"    ,CDlpFile_LibsndfileImport           );
  ADD_FILETYPE("aiff"     ,"data"     ,EXPORT_FILE,   "Audio Interchange File Format"    ,CDlpFile_LibsndfileExport           );
  ADD_FILETYPE("au"       ,"data"     ,IMPORT_FILE,  "SUN AU audio"                     ,CDlpFile_LibsndfileImport           );
  ADD_FILETYPE("au"       ,"data"     ,EXPORT_FILE,  "SUN AU audio"                     ,CDlpFile_LibsndfileExport           );
  ADD_FILETYPE("phd"      ,"data"     ,IMPORT_FILE,"PhonDat"                          ,CDlpFile_ImportPhDToData            );
  ADD_FILETYPE("vm2_nist" ,"data"     ,IMPORT_FILE,  "Verbmobil2 signal (NIST)"         ,CDlpFile_ImportDataFromVm2Nist      );
  ADD_FILETYPE("esps_lab" ,"data"     ,IMPORT_FILE, "ESPS label"                       ,CDlpFile_ImportEspsLabToData        );
  ADD_FILETYPE("esps_lab" ,"data"     ,EXPORT_FILE, "ESPS label"                       ,CDlpFile_ExportEspsLabFromData      );
  ADD_FILETYPE("pm"       ,"data"     ,IMPORT_FILE, "Period marker"                    ,CDlpFile_ImportPmToData             );
  ADD_FILETYPE("pm"       ,"data"     ,EXPORT_FILE, "Period marker"                    ,CDlpFile_ExportPmFromData           );
  ADD_FILETYPE("pm.txt"   ,"data"     ,IMPORT_FILE,  "Period marker (wavesurfer)"       ,CDlpFile_ImportPmTxtToData          );
  ADD_FILETYPE("pm.txt"   ,"data"     ,EXPORT_FILE,  "Period marker (wavesurfer)"       ,CDlpFile_ExportPmTxtFromData        );
  ADD_FILETYPE("raw"      ,"data"     ,IMPORT_FILE, "RAW (binary)"                     ,CDlpFile_ImportRawToData            );
  ADD_FILETYPE("raw"      ,"data"     ,EXPORT_FILE, "RAW (binary)"                     ,CDlpFile_ExportRawFromData          );
  ADD_FILETYPE("IntRas"   ,"data"     ,IMPORT_FILE,  "Fraunhofer (IZFP) IntRas"         ,CDlpFile_ImportIzfpRsToData         );
  ADD_FILETYPE("FIRS04A"  ,"data"     ,IMPORT_FILE,  "Fraunhofer (IZFP) FIRS04A"        ,CDlpFile_ImportIzfpRsToData         );
  ADD_FILETYPE("into"     ,"data"     ,IMPORT_FILE,"Into"                             ,CDlpFile_ImportIntoToData           );
  ADD_FILETYPE("into"     ,"data"     ,EXPORT_FILE,"Into"                             ,CDlpFile_ExportIntoFromData         );
  ADD_FILETYPE("mid"      ,"data"     ,IMPORT_FILE, "Midi Notes"                       ,CDlpFile_Midi_ImportMidi            );
  ADD_FILETYPE("mid"      ,"data"     ,EXPORT_FILE, "Midi Notes"                       ,CDlpFile_Midi_ExportMidi            );
  ADD_FILETYPE("dot"      ,"fst"      ,EXPORT_FILE,    "AT&T DOT for GraphViz (ASCII)"    ,CDlpFile_Gph_ExportDot              );
  ADD_FILETYPE("svg"      ,"fst"      ,EXPORT_FILE,  "Scalable vector graphic"          ,CDlpFile_Gph_ExportDotTx            );
  ADD_FILETYPE("png"      ,"fst"      ,EXPORT_FILE,  "Portable network graphic"         ,CDlpFile_Gph_ExportDotTx            );
  ADD_FILETYPE("ps"       ,"fst"      ,EXPORT_FILE,        "Postscript (EPSF)       "         ,CDlpFile_Gph_ExportDotTx            );
  ADD_FILETYPE("itp"      ,"fst"      ,EXPORT_FILE, "dLabPro script"                   ,CDlpFile_Gph_ExportItp              );
  ADD_FILETYPE("fsm-a"    ,"fst"      ,EXPORT_FILE,   "AT&T FSM Toolkit (ASCII)"         ,CDlpFile_Gph_ExportFsm              );
  ADD_FILETYPE("fsm-a"    ,"fst"      ,IMPORT_FILE,   "AT&T FSM Toolkit (ASCII)"         ,CDlpFile_Gph_ImportFsm              );
  ADD_FILETYPE("fsm-t"    ,"fst"      ,EXPORT_FILE,   "AT&T FSM Toolkit (ASCII)"         ,CDlpFile_Gph_ExportFsm              );
  ADD_FILETYPE("fsm-t"    ,"fst"      ,IMPORT_FILE,   "AT&T FSM Toolkit (ASCII)"         ,CDlpFile_Gph_ImportFsm              );
  ADD_FILETYPE("htk"      ,"hmm"      ,EXPORT_FILE, "HTK hmmdefs"                      ,CDlpFile_Hmm_ExportHtk              );
  ADD_FILETYPE("pstricks" ,"data"     ,EXPORT_FILE,"PSTricks"                         ,CDlpFile_ExportPstricksFromData     );
  ADD_FILETYPE("inv_descr","data"     ,IMPORT_FILE,   "Inventory description file (.inv)",CDlpFile_ImportInvDescrToData       );
  ADD_FILETYPE("inv_descr","data"     ,EXPORT_FILE,   "Inventory description file (.inv)",CDlpFile_ExportInvDescrFromData     );

	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CDlpFile_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	DEBUGMSG(-1,"CDlpFile_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */

  CData* idFlistData;
  char   lpsB1[255];
  char   lpsB2[255];
  char   lpsB3[ 32];
  char   lpsB4[255];

	if (_this->m_idFlistData==NULL) IFIELD_RESET(CData,"flist_data");
  IFIELD_RESET(CData,"recfile");
  dlp_strcpy(lpsB1,_this->m_lpsFlist);
  dlp_strcpy(lpsB2,_this->m_lpsPath);
  dlp_strcpy(lpsB3,_this->m_lpsExt);
  dlp_strcpy(lpsB4,_this->m_lpsSep);
  idFlistData = AS(CData,_this->m_idFlistData);
  _this->m_idFlistData = NULL;

  RESET;

  _this->m_idFlistData = BASEINST(idFlistData);
  dlp_strcpy(_this->m_lpsFlist,lpsB1);
  dlp_strcpy(_this->m_lpsPath ,lpsB2);
  dlp_strcpy(_this->m_lpsExt  ,lpsB3);
  dlp_strcpy(_this->m_lpsSep  ,lpsB4);
  _this->m_nLen = CData_GetNRecs(AS(CData,_this->m_idFlistData));

	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CDlpFile_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CDlpFile_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CDlpFile_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CDlpFile_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CDlpFile_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CDlpFile_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CDlpFile_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CDlpFile* CDlpFile_CreateInstance(const char* lpName)
{
	CDlpFile* lpNewInstance;
	ICREATEEX(CDlpFile,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CDlpFile_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOINSTANCE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CDlpFile::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CDlpFile::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CDlpFile_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CDlpFile_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "file";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "File list processor and import/export filters";
	lpClassWord->ex.fct.lpAutoname  = "stdfile";
	lpClassWord->ex.fct.lpCname     = "CDlpFile";
	lpClassWord->ex.fct.lpAuthor    = "M. Wolff, M. Eichner and M. Cuevas";

	dlp_strcpy(lpClassWord->lpName             ,"file");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.1.2");

	return O_K;
}

INT16 CDlpFile_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CDlpFile_GetClassInfo(lpClassWord);
}

BOOL CDlpFile_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"file",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CDlpFile_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	DEBUGMSG(-1,"CDlpFile_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bAppend = FALSE;
	_this->m_bBig = FALSE;
	_this->m_bCompress = FALSE;
	_this->m_bDir = FALSE;
	_this->m_bExecute = FALSE;
	_this->m_bLittle = FALSE;
	_this->m_bPstComma = FALSE;
	_this->m_bPstContour = FALSE;
	_this->m_bPstHalfspectrum = FALSE;
	_this->m_bPstLegend = FALSE;
	_this->m_bPstTriglabels = FALSE;
	_this->m_bPstXYPlot = FALSE;
	_this->m_bReverse = FALSE;
	_this->m_bStrings = FALSE;
	_this->m_bTranspose = FALSE;
	_this->m_bZip = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CDlpFile_OnExists(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sFilename;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sFilename = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CDlpFile_Exists(_this, sFilename));
	return __nErr;
}

INT16 CDlpFile_OnExport(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	const char* sFilename;
	const char* sFilter;
	CDlpObject* iInst;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iInst = MIC_GET_I(1,1);
	sFilter = MIC_GET_S(2,0);
	sFilename = MIC_GET_S(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CDlpFile_Export(_this, sFilename, sFilter, iInst);
	return __nErr;
}

INT16 CDlpFile_OnGetRootClass(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sFilename;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sFilename = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S(CDlpFile_GetRootClass(_this, sFilename));
	return __nErr;
}

INT16 CDlpFile_OnGetlen(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CDlpFile_Getlen(_this));
	return __nErr;
}

INT16 CDlpFile_OnImport(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	const char* sFilename;
	const char* sFilter;
	CDlpObject* iInst;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iInst = MIC_GET_I(1,1);
	sFilter = MIC_GET_S(2,0);
	sFilename = MIC_GET_S(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CDlpFile_Import(_this, sFilename, sFilter, iInst);
	return __nErr;
}

INT16 CDlpFile_OnList(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CDlpFile_List(_this);
	return __nErr;
}

INT16 CDlpFile_OnNext(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S(CDlpFile_Next(_this));
	return __nErr;
}

INT16 CDlpFile_OnPartition(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	file* iSrc;
	FLOAT64 nPartSize;
	INT32 nPartNum;
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nPartNum = (INT32)MIC_GET_N(1,0);
	nPartSize = MIC_GET_N(2,1);
	iSrc = MIC_GET_I_EX(iSrc,file,3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CDlpFile_Partition(_this, iSrc, nPartSize, nPartNum);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CDlpFile_Export(CDlpFile* _this, const char* sFilename, const char* sFilter, CDlpObject* iInst)
{
    return CDlpFile_ImportExport(_this,sFilename,sFilter,iInst,EXPORT_FILE);
	return O_K;
}

INT32 CDlpFile_Getlen(CDlpFile* _this)
{
    FILE*    f                      = NULL;
    INT32  nCtr                   = 0;
    char  lpsBuffer[L_INPUTLINE] = "";

    if (!dlp_strlen(_this->m_lpsFlist))
    {
      IERROR(_this,FIL_NEEDFL,0,0,0);
      return 0;
    }
    f = fopen(_this->m_lpsFlist,"r");
    if (!f)
    {
      IERROR(_this,ERR_FILEOPEN,_this->m_lpsFlist,"reading",0);
      return 0;
    }
    while (fgets(lpsBuffer,L_INPUTLINE,f))
      if(dlp_strlen(dlp_strtrimleft(dlp_strtrimright(lpsBuffer))))
        nCtr++;
    fclose(f);
    return nCtr;
	return 0;
}

INT16 CDlpFile_Import(CDlpFile* _this, const char* sFilename, const char* sFilter, CDlpObject* iInst)
{
    return CDlpFile_ImportExport(_this,sFilename,sFilter,iInst,IMPORT_FILE);
	return O_K;
}

INT16 CDlpFile_List(CDlpFile* _this)
{
    CFILE_FTYPE* lpType = NULL;
    lnode_t*      lpNode = NULL;

    printf("\n"); dlp_fprint_x_line(stdout,'-',80);
    printf(              "\n Name      \tClass     \tMode  \tDescription\n");
    dlp_fprint_x_line(stdout,'-',80); printf("\n");

    for(lpNode=list_first(_this->m_lpFtypes); lpNode; lpNode=list_next(_this->m_lpFtypes,lpNode))
    {
      lpType = (CFILE_FTYPE*)lnode_get(lpNode);
      DLPASSERT(lpType);
      printf( " %-10s\t%-10s\t%s\t%s\n",lpType->lpName,lpType->lpClassName,
             lpType->nMode==IMPORT_FILE?"Import":"Export",lpType->lpDescr);
    }

    dlp_fprint_x_line(stdout,'-',80); printf("\n");
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
INT16 CDlpFile_OnExtChanged(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
    /* Remove leading dots */
    while (_this->m_lpsExt[0] == '.') memmove(_this->m_lpsExt,&_this->m_lpsExt[1],dlp_strlen(_this->m_lpsExt));
	}

	return O_K;
}

INT16 CDlpFile_OnFlistChanged(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
    CData_Reset(_this->m_idFlistData, TRUE);
    if(dlp_strlen(_this->m_lpsFlist))
    {
      ISETOPTION(_this,"/strings");
      CDlpFile_Import(_this,_this->m_lpsFlist,"ascii",_this->m_idFlistData);
      IRESETOPTIONS(_this);
      _this->m_nLen = CData_GetNRecs(AS(CData,_this->m_idFlistData));
    }
    else _this->m_nLen = 0;
    _this->m_nNfile = -1;
	}

	return O_K;
}

INT16 CDlpFile_OnFlistDataChanged(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
    _this->m_nLen = CData_GetNRecs(AS(CData,_this->m_idFlistData));
	}

	return O_K;
}

INT16 CDlpFile_OnPathChanged(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CDlpFile,NOT_EXEC);
	{
    /* Remove tailing slashes/backslashes */
    char* tx = &_this->m_lpsPath[dlp_strlen(_this->m_lpsPath)-1];
    while (*tx == '\\' || *tx == '/')
    {
      *tx = 0;
      if (tx == _this->m_lpsPath) break;
      tx--;
    }
	}

	return O_K;
}

/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CDlpFile::CDlpFile(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CDlpFile_Constructor(this,lpInstanceName,bCallVirtual);
}

CDlpFile::~CDlpFile()
{
	CDlpFile_Destructor(this);
}

INT16 CDlpFile::AutoRegisterWords()
{
	return CDlpFile_AutoRegisterWords(this);
}

INT16 CDlpFile::Init(BOOL bCallVirtual)
{
	return CDlpFile_Init(this,bCallVirtual);
}

INT16 CDlpFile::Reset(BOOL bResetMembers)
{
	return CDlpFile_Reset(this,bResetMembers);
}

INT16 CDlpFile::ClassProc()
{
	return CDlpFile_ClassProc(this);
}

INT16 CDlpFile::Serialize(CDN3Stream* lpDest)
{
	return CDlpFile_Serialize(this,lpDest);
}

INT16 CDlpFile::SerializeXml(CXmlStream* lpDest)
{
	return CDlpFile_SerializeXml(this,lpDest);
}

INT16 CDlpFile::Deserialize(CDN3Stream* lpSrc)
{
	return CDlpFile_Deserialize(this,lpSrc);
}

INT16 CDlpFile::DeserializeXml(CXmlStream* lpSrc)
{
	return CDlpFile_DeserializeXml(this,lpSrc);
}

INT16 CDlpFile::Copy(CDlpObject* __iSrc)
{
	return CDlpFile_Copy(this,__iSrc);
}

INT16 CDlpFile::InstallProc(void* lpItp)
{
	return CDlpFile_InstallProc(lpItp);
}

CDlpFile* CDlpFile::CreateInstance(const char* lpName)
{
	return CDlpFile_CreateInstance(lpName);
}

INT16 CDlpFile::GetClassInfo(SWord* lpClassWord)
{
	return CDlpFile_GetClassInfo(lpClassWord);
}

INT16 CDlpFile::GetInstanceInfo(SWord* lpClassWord)
{
	return CDlpFile_GetInstanceInfo(this,lpClassWord);
}

BOOL CDlpFile::IsKindOf(const char* lpClassName)
{
	return CDlpFile_IsKindOf(this,lpClassName);
}

INT16 CDlpFile::ResetAllOptions(BOOL bInit)
{
	return CDlpFile_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CDlpFile::OnExists()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnExists(this);
}

INT16 CDlpFile::OnExport()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnExport(this);
}

INT16 CDlpFile::OnGetRootClass()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnGetRootClass(this);
}

INT16 CDlpFile::OnGetlen()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnGetlen(this);
}

INT16 CDlpFile::OnImport()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnImport(this);
}

INT16 CDlpFile::OnList()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnList(this);
}

INT16 CDlpFile::OnNext()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnNext(this);
}

INT16 CDlpFile::OnPartition()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CDlpFile_OnPartition(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CDlpFile::Export(const char* sFilename, const char* sFilter, CDlpObject* iInst)
{
	return CDlpFile_Export(this,sFilename, sFilter, iInst);
}

INT32 CDlpFile::Getlen()
{
	return CDlpFile_Getlen(this);
}

INT16 CDlpFile::Import(const char* sFilename, const char* sFilter, CDlpObject* iInst)
{
	return CDlpFile_Import(this,sFilename, sFilter, iInst);
}

INT16 CDlpFile::List()
{
	return CDlpFile_List(this);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
INT16 CDlpFile::OnExtChanged()
{
	return CDlpFile_OnExtChanged(this);
}

INT16 CDlpFile::OnFlistChanged()
{
	return CDlpFile_OnFlistChanged(this);
}

INT16 CDlpFile::OnFlistDataChanged()
{
	return CDlpFile_OnFlistDataChanged(this);
}

INT16 CDlpFile::OnPathChanged()
{
	return CDlpFile_OnPathChanged(this);
}

/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
BOOL CDlpFile::Exists(const char* sFilename)
{
	return CDlpFile_Exists(this, sFilename);
}

const char* CDlpFile::GetRootClass(const char* lpsFilename)
{
	return CDlpFile_GetRootClass(this, lpsFilename);
}

const char* CDlpFile::Next()
{
	return CDlpFile_Next(this);
}

INT16 CDlpFile::Partition(CDlpFile* iSrc, FLOAT64 nPartSize, INT32 nPartNum)
{
	return CDlpFile_Partition(this, iSrc, nPartSize, nPartNum);
}

INT16 CDlpFile::ImportAsciiToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportAsciiToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ExportAsciiFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportAsciiFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::LibsndfileImport(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_LibsndfileImport(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::LibsndfileExport(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_LibsndfileExport(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ImportPhDToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportPhDToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ImportEspsLabToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportEspsLabToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ExportEspsLabFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportEspsLabFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ImportPmToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportPmToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ImportPmTxtToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportPmTxtToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ExportPmFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportPmFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ExportPmTxtFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportPmTxtFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ImportIntoToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportIntoToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ExportIntoFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportIntoFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ImportRawToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportRawToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ImportIzfpRsToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportIzfpRsToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ExportRawFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportRawFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ImportWaveToData(const char* sFilename, CDlpObject* iDest, const char* sFiletype)
{
	return CDlpFile_ImportWaveToData(this, sFilename, iDest, sFiletype);
}

INT16 CDlpFile::ImportInvDescrToData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ImportInvDescrToData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ExportInvDescrFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportInvDescrFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::ExportPstricksFromData(const char* sFilename, CDlpObject* iSrc, const char* sFiletype)
{
	return CDlpFile_ExportPstricksFromData(this, sFilename, iSrc, sFiletype);
}

INT16 CDlpFile::Gph_ExportDot(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Gph_ExportDot(this, lpsFilename, iSrc, lpsFiletype);
}

INT16 CDlpFile::Gph_ExportDotTx(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Gph_ExportDotTx(this, lpsFilename, iSrc, lpsFiletype);
}

INT16 CDlpFile::Gph_ExportFsm(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Gph_ExportFsm(this, lpsFilename, iSrc, lpsFiletype);
}

INT16 CDlpFile::Gph_ImportFsm(const char* lpsFilename, CDlpObject* iDst, const char* lpsFiletype)
{
	return CDlpFile_Gph_ImportFsm(this, lpsFilename, iDst, lpsFiletype);
}

void CDlpFile::Gph_ExportItp_WriteCI(FILE* fDst, CData* idSrc, INT32 nFC, INT32 nR)
{
	CDlpFile_Gph_ExportItp_WriteCI(fDst, idSrc, nFC, nR);
}

INT16 CDlpFile::Gph_ExportItp(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Gph_ExportItp(this, lpsFilename, iSrc, lpsFiletype);
}

INT16 CDlpFile::Hmm_ExportHtk(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Hmm_ExportHtk(this, lpsFilename, iSrc, lpsFiletype);
}

INT16 CDlpFile::ImportExport(const char* sFilename, const char* sFilter, CDlpObject* iInst, INT16 nMode)
{
	return CDlpFile_ImportExport(this, sFilename, sFilter, iInst, nMode);
}

void CDlpFile::FreeFTypeList(list_t* lpList, lnode_t* lpNode, void* context)
{
	CDlpFile_FreeFTypeList(lpList, lpNode, context);
}

int CDlpFile::CompareFTypeList(const void* key, const void* node)
{
	return CDlpFile_CompareFTypeList(key, node);
}

void CDlpFile::FlipNumericData(CData* idDest)
{
	CDlpFile_FlipNumericData(idDest);
}

BOOL CDlpFile::ParseNIST(char* sLine, char** sKey, char** sType, char** sValue)
{
	return CDlpFile_ParseNIST(sLine, sKey, sType, sValue);
}

INT16 CDlpFile::ImportDataFromVm2Nist(const char* sFilename, CDlpObject* iDst, const char* sFiletype)
{
	return CDlpFile_ImportDataFromVm2Nist(this, sFilename, iDst, sFiletype);
}

INT16 CDlpFile::Midi_ImportMidi(const char* lpsFilename, CDlpObject* iDst, const char* lpsFiletype)
{
	return CDlpFile_Midi_ImportMidi(this, lpsFilename, iDst, lpsFiletype);
}

INT16 CDlpFile::Midi_ExportMidi(const char* lpsFilename, CDlpObject* iSrc, const char* lpsFiletype)
{
	return CDlpFile_Midi_ExportMidi(this, lpsFilename, iSrc, lpsFiletype);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
